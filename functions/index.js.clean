const functions = require('firebase-functions');
const express = require('express');
const path = require('path');
const fs = require('fs');
const bodyParser = require('body-parser');
const cookieParser = require('cookie-parser');
const admin = require('firebase-admin');
const crypto = require('crypto');

// Initialize Firebase Admin SDK
admin.initializeApp();

// Create our own simple Express app just for Firebase Functions
const app = express();

// Add middleware
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use(cookieParser());

// Simple in-memory session store (this would be a database in production)
// IMPORTANT: This is NOT suitable for production use as it resets when the function instance is recycled
// In a real app, use Firestore, Firebase RTDB, or another persistent database for sessions
let sessions = {};
console.log('Initializing session store');

// Initialize Firestore for persistent session storage
const db = admin.firestore();
const sessionsCollection = db.collection('sessions');
console.log('Initialized Firestore for persistent sessions');

// URL shortening utilities
// Create an in-memory store for URL mappings
let urlMappings = {};

// Function to create a short code for a URL
function createShortCode(url) {
  // First check if we already have a code for this URL
  for (const [code, storedUrl] of Object.entries(urlMappings)) {
    if (storedUrl === url) {
      return code;
    }
  }
  
  // If not, create a new short code
  // Use the first 6 characters of the MD5 hash for uniqueness
  const hash = crypto.createHash('md5').update(url).digest('hex');
  const shortCode = hash.substring(0, 6);
  
  // Store the mapping
  urlMappings[shortCode] = url;
  console.log(`Created new short code ${shortCode} for ${url}`);
  
  return shortCode;
}

// Function to retrieve a URL from a short code
function getUrlFromShortCode(code) {
  return urlMappings[code];
}

// Helper functions for session management
async function createSession(email, uid) {
  const sessionToken = Math.random().toString(36).substring(2, 15);
  const sessionData = {
    email,
    uid,
    loggedIn: true,
    createdAt: new Date().toISOString()
  };
  
  // Store in Firestore
  await sessionsCollection.doc(sessionToken).set(sessionData);
  console.log('Created persistent session:', sessionToken);
  
  // Also keep in memory for faster access
  sessions[sessionToken] = sessionData;
  
  return sessionToken;
}

async function getSession(sessionToken) {
  if (!sessionToken) return null;
  
  // First try memory cache
  if (sessions[sessionToken]) {
    return sessions[sessionToken];
  }
  
  // If not in memory, try Firestore
  try {
    const sessionDoc = await sessionsCollection.doc(sessionToken).get();
    if (sessionDoc.exists) {
      const sessionData = sessionDoc.data();
      // Cache in memory
      sessions[sessionToken] = sessionData;
      return sessionData;
    }
  } catch (error) {
    console.error('Error fetching session:', error);
  }
  
  return null;
}

async function deleteSession(sessionToken) {
  if (!sessionToken) return;
  
  // Delete from Firestore
  try {
    await sessionsCollection.doc(sessionToken).delete();
    // Also remove from memory cache
    delete sessions[sessionToken];
  } catch (error) {
    console.error('Error deleting session:', error);
  }
}

// Debug route to show current sessions (remove in production)
app.get('/_debug/sessions', async (req, res) => {
  // Only show this in development
  if (process.env.NODE_ENV === 'production') {
    return res.status(404).send('Not found');
  }
  
  try {
    const sessionsSnapshot = await sessionsCollection.get();
    const sessionsList = [];
    
    sessionsSnapshot.forEach(doc => {
      const session = doc.data();
      sessionsList.push({
        id: doc.id,
        email: session.email,
        loggedIn: session.loggedIn,
        createdAt: session.createdAt
      });
    });
    
    res.json({
      count: sessionsList.length,
      sessions: sessionsList,
      memoryCache: {
        count: Object.keys(sessions).length,
        keys: Object.keys(sessions)
      }
    });
  } catch (error) {
    console.error('Error fetching sessions:', error);
    res.status(500).json({ error: 'Error fetching sessions' });
  }
});

// Debug endpoint to check if a user exists in Firebase Auth
app.get('/_debug/check-user', async (req, res) => {
  // Only show this in development
  if (process.env.NODE_ENV === 'production') {
    return res.status(404).send('Not found');
  }
  
  const email = req.query.email;
  if (!email) {
    return res.status(400).json({ error: 'Email parameter required' });
  }
  
  try {
    console.log('Checking if user exists:', email);
    const userRecord = await admin.auth().getUserByEmail(email)
      .catch(error => {
        console.log('User lookup error:', error.code, error.message);
        return null;
      });
    
    if (userRecord) {
      res.json({
        exists: true,
        uid: userRecord.uid,
        email: userRecord.email,
        emailVerified: userRecord.emailVerified,
        disabled: userRecord.disabled,
        creationTime: userRecord.metadata.creationTime,
        lastSignInTime: userRecord.metadata.lastSignInTime,
        providerData: userRecord.providerData
      });
    } else {
      res.json({ exists: false });
    }
  } catch (error) {
    console.error('Error checking user:', error);
    res.status(500).json({ error: 'Server error checking user' });
  }
});

// Debug endpoint to create a user in Firebase Auth
app.get('/_debug/create-user', async (req, res) => {
  // Only show this in development
  if (process.env.NODE_ENV === 'production') {
    return res.status(404).send('Not found');
  }
  
  const email = req.query.email;
  const password = req.query.password || 'Test123!'; // Default password
  
  if (!email) {
    return res.status(400).json({ error: 'Email parameter required' });
  }
  
  try {
    // First check if user already exists
    const existingUser = await admin.auth().getUserByEmail(email)
      .catch(() => null);
      
    if (existingUser) {
      return res.json({
        message: 'User already exists',
        uid: existingUser.uid,
        email: existingUser.email
      });
    }
    
    // Create the user
    console.log('Creating new user:', email);
    const userRecord = await admin.auth().createUser({
      email: email,
      password: password,
      emailVerified: true
    });
    
    res.json({
      message: 'User created successfully',
      uid: userRecord.uid,
      email: userRecord.email
    });
  } catch (error) {
    console.error('Error creating user:', error);
    res.status(500).json({ 
      error: 'Error creating user',
      code: error.code,
      message: error.message
    });
  }
});

// Create a custom token for testing
app.get('/_debug/create-custom-token', async (req, res) => {
  // Only show this in development
  if (process.env.NODE_ENV === 'production') {
    return res.status(404).send('Not found');
  }
  
  const email = req.query.email;
  if (!email) {
    return res.status(400).json({ error: 'Email parameter required' });
  }
  
  try {
    // Get user by email
    const userRecord = await admin.auth().getUserByEmail(email)
      .catch(error => {
        console.log('User lookup error:', error.code, error.message);
        return null;
      });
    
    if (!userRecord) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // Create a custom token
    const customToken = await admin.auth().createCustomToken(userRecord.uid);
    
    // Create a direct session without further verification
    const sessionToken = await createSession(email, userRecord.uid);
    
    // Determine if the request is from a secure context
    const isSecure = req.secure || req.headers['x-forwarded-proto'] === 'https';
    
    // Extract the host domain for cookies
    let domain = 'dlzz.pro';
    if (req.headers.host) {
      // Extract just the domain part without port
      domain = req.headers.host.split(':')[0];
    }
    
    console.log(`Setting cookie for domain: ${domain}, secure: ${isSecure}`);
    
    // Set cookie with appropriate settings
    res.cookie('session', sessionToken, { 
      maxAge: 24 * 60 * 60 * 1000,
      httpOnly: true,
      secure: isSecure,
      domain: domain,
      path: '/',
      sameSite: 'lax'     // 'strict', 'lax', or 'none' for cross-site
    });
    
    // Also set a non-httpOnly cookie that JavaScript can access as a backup
    res.cookie('session_backup', sessionToken, { 
      maxAge: 24 * 60 * 60 * 1000,
      httpOnly: false,
      secure: isSecure,
      domain: domain,
      path: '/',
      sameSite: 'lax'
    });
    
    res.json({
      message: 'Custom token created and session set',
      uid: userRecord.uid,
      email: userRecord.email,
      sessionToken: sessionToken,
      customToken: customToken,
      cookieInfo: {
        name: 'session',
        value: sessionToken,
        maxAge: 24 * 60 * 60 * 1000,
        path: '/',
        domain: domain
      }
    });
  } catch (error) {
    console.error('Error creating custom token:', error);
    res.status(500).json({ 
      error: 'Error creating custom token',
      code: error.code,
      message: error.message
    });
  }
});

// Add a simple route for testing
app.get('/test', (req, res) => {
  res.send('Hello World! The function is working.');
});

// Add an info route to show file paths and environment
app.get('/info', (req, res) => {
  const info = {
    currentDir: __dirname,
    files: fs.readdirSync(__dirname),
    distExists: fs.existsSync(path.join(__dirname, 'dist')),
    distFiles: fs.existsSync(path.join(__dirname, 'dist')) ? fs.readdirSync(path.join(__dirname, 'dist')) : [],
    publicExists: fs.existsSync(path.join(__dirname, 'dist', 'public')),
    publicFiles: fs.existsSync(path.join(__dirname, 'dist', 'public')) ? fs.readdirSync(path.join(__dirname, 'dist', 'public')) : [],
    env: process.env.NODE_ENV || 'development'
  };
  res.json(info);
});

// Add a basic login page
app.get('/login', (req, res) => {
  const loginPage = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>LinkTracker - Login</title>
      <style>
        body {
          font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          background-color: hsl(226, 100%, 82%);
          display: flex;
          justify-content: center;
          align-items: center;
          height: 100vh;
          margin: 0;
        }
        .login-container {
          background-color: white;
          border-radius: 10px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
          padding: 2rem;
          width: 100%;
          max-width: 400px;
        }
        h1 {
          color: hsl(228, 100%, 75%);
          margin-top: 0;
          text-align: center;
        }
        .form-group {
          margin-bottom: 1.5rem;
        }
        label {
          display: block;
          margin-bottom: 0.5rem;
          font-weight: 500;
        }
        input {
          width: 100%;
          padding: 0.75rem;
          border: 1px solid hsl(227, 94%, 74%);
          border-radius: 0.5rem;
          font-size: 1rem;
          box-sizing: border-box;
        }
        button {
          background-color: hsl(228, 100%, 75%);
          color: white;
          border: none;
          border-radius: 0.5rem;
          padding: 0.75rem 1.5rem;
          font-size: 1rem;
          font-weight: 600;
          cursor: pointer;
          width: 100%;
          transition: background-color 0.2s;
        }
        button:hover {
          background-color: hsl(228, 100%, 70%);
        }
        .error {
          color: #e74c3c;
          margin-top: 1rem;
          text-align: center;
        }
        .or-divider {
          display: flex;
          align-items: center;
          margin: 1.5rem 0;
          color: #7f8c8d;
        }
        .or-divider::before, .or-divider::after {
          content: "";
          flex: 1;
          border-bottom: 1px solid #ecf0f1;
        }
        .or-divider span {
          padding: 0 10px;
        }
        .google-btn {
          background-color: white;
          color: #4285F4;
          border: 1px solid #dadce0;
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 10px;
        }
        .google-btn:hover {
          background-color: #f8f8f8;
        }
        .google-btn img {
          width: 18px;
          height: 18px;
        }
        .error-banner {
          background-color: #ffeaea;
          border: 1px solid #e74c3c;
          color: #e74c3c;
          padding: 0.75rem;
          border-radius: 0.5rem;
          margin-bottom: 1.5rem;
          font-size: 0.9rem;
        }
        .error-banner a {
          color: #e74c3c;
          text-decoration: underline;
          font-weight: bold;
        }
      </style>
      <!-- Firebase App (the core Firebase SDK) -->
      <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
      <!-- Firebase Authentication -->
      <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
    </head>
    <body>
      <div class="login-container">
        <h1>LinkTracker</h1>
        <div id="errorBanner" class="error-banner" style="display: none;">
          Session error detected. If you're having trouble logging in, try our 
          <a href="/_debug/direct-login">direct login</a> option.
        </div>
        <form id="loginForm">
          <div class="form-group">
            <label for="email">Email</label>
            <input type="email" id="email" name="email" required>
          </div>
          <div class="form-group">
            <label for="password">Password</label>
            <input type="password" id="password" name="password" required>
          </div>
          <button type="submit">Log In</button>
        </form>
        
        <div class="or-divider">
          <span>OR</span>
        </div>
        
        <button id="googleSignIn" class="google-btn">
          <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google logo">
          Sign in with Google
        </button>
        
        <p id="errorMessage" class="error" style="display: none;">Invalid email or password</p>
      </div>

      <script>
        // Initialize Firebase
        const firebaseConfig = {
          apiKey: "AIzaSyDTFax8ETKwJENZR7GUXAGh8av_TfoAWbA",
          authDomain: "dlzz-pro-b1c80.firebaseapp.com",
          projectId: "dlzz-pro-b1c80",
          storageBucket: "dlzz-pro-b1c80.firebasestorage.app",
          messagingSenderId: "154150291886",
          appId: "1:154150291886:web:0047222aecc1c8f7b7203f",
          measurementId: "G-X31TZ4WTCQ"
        };
        
        firebase.initializeApp(firebaseConfig);
        
        // Check if user is already signed in
        firebase.auth().onAuthStateChanged(function(user) {
          if (user) {
            console.log('User already signed in:', user.email);
          } else {
            console.log('No user is signed in.');
          }
        });
        
        // Check for redirect result on page load
        document.addEventListener('DOMContentLoaded', async () => {
          const errorMessage = document.getElementById('errorMessage');
          
          try {
            // Get redirect result
            const result = await firebase.auth().getRedirectResult();
            
            // If we have a user from redirect, process the sign-in
            if (result.user) {
              console.log('Detected redirect completion');
              
              try {
                // Get the user's ID token
                const idToken = await result.user.getIdToken(true);
                const user = result.user;
                
                // Get provider data
                const providerData = user.providerData && user.providerData.length > 0 
                  ? user.providerData[0].providerId 
                  : 'unknown';
                  
                console.log('Auth provider:', providerData);
                
                try {
                  // Send the token to your server
                  const response = await fetch('/api/auth', {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                      idToken, 
                      provider: providerData.includes('google') ? 'google' : providerData,
                      email: user.email
                    })
                  });
                  
                  if (response.ok) {
                    console.log('Server accepted Google token');
                    
                    try {
                      // Try to get the response data
                      const data = await response.json();
                      console.log('Auth response data:', data);
                      
                      // If we have cookie info in the response, set it manually
                      if (data.cookieInfo) {
                        console.log('Setting cookie manually:', data.cookieInfo.name);
                        document.cookie = data.cookieInfo.name + '=' + data.cookieInfo.value + 
                          '; max-age=' + (data.cookieInfo.maxAge/1000) + 
                          '; path=' + data.cookieInfo.path + 
                          '; domain=' + data.cookieInfo.domain;
                      }
                    } catch (parseError) {
                      console.warn('Could not parse response JSON:', parseError);
                    }
                    
                    console.log('Redirecting to dashboard...');
                    window.location.href = '/dashboard';
                  } else {
                    // If server rejected the token
                    console.error('Server rejected Google token');
                    const responseData = await response.json().catch(() => ({ error: 'Unknown server error' }));
                    
                    // If the error is about unauthorized email, sign out the user
                    if (responseData.code === 'auth/unauthorized-email') {
                      await firebase.auth().signOut();
                    }
                    
                    errorMessage.style.display = 'block';
                    errorMessage.textContent = responseData.error || 'Server error. Please try again.';
                  }
                } catch (fetchError) {
                  console.error('Network error during authentication:', fetchError);
                  errorMessage.style.display = 'block';
                  errorMessage.textContent = 'Network error. Please try again.';
                }
              } catch (error) {
                console.error('Error processing redirect result:', error);
                errorMessage.style.display = 'block';
                errorMessage.textContent = 'Error signing in with Google. Please try again.';
              }
            }
          } catch (error) {
            console.error('Error getting redirect result:', error);
            errorMessage.style.display = 'block';
            errorMessage.textContent = 'Error completing sign-in. Please try again.';
          }
        });

        // Handle form submission
        document.getElementById('loginForm').addEventListener('submit', async function(e) {
          e.preventDefault();
          
          const email = document.getElementById('email').value;
          const password = document.getElementById('password').value;
          const errorMessage = document.getElementById('errorMessage');
          
          // Show loading state
          const submitButton = this.querySelector('button[type="submit"]');
          const originalButtonText = submitButton.textContent;
          submitButton.textContent = 'Logging in...';
          submitButton.disabled = true;
          
          try {
            console.log('Attempting to sign in with Firebase...');
            // Sign in with email and password
            const userCredential = await firebase.auth().signInWithEmailAndPassword(email, password);
            
            console.log('Firebase authentication successful');
            // If login successful, get the user's ID token
            const idToken = await userCredential.user.getIdToken();
            
            console.log('Got ID token, sending to server...');
            // Send the token to your server for verification and session creation
            const response = await fetch('/api/auth', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ idToken })
            });
            
            if (response.ok) {
              console.log('Server accepted token, redirecting to dashboard...');
              // If server accepted the token, redirect to dashboard
              // Instead of directly changing location, wait a bit to ensure cookie is set
              setTimeout(() => {
                window.location.href = '/dashboard';
              }, 500);
            } else {
              // If server rejected the token
              console.error('Server rejected token');
              const responseData = await response.json();
              errorMessage.style.display = 'block';
              errorMessage.textContent = responseData.error || 'Server error. Please try again.';
              
              // Reset button
              submitButton.textContent = originalButtonText;
              submitButton.disabled = false;
            }
          } catch (error) {
            // Handle authentication errors
            console.error('Authentication error:', error);
            errorMessage.style.display = 'block';
            
            switch (error.code) {
              case 'auth/user-not-found':
              case 'auth/wrong-password':
                errorMessage.textContent = 'Invalid email or password';
                break;
              case 'auth/too-many-requests':
                errorMessage.textContent = 'Too many failed login attempts. Please try again later.';
                break;
              default:
                errorMessage.textContent = 'Error signing in. Please try again.';
            }
            
            // Reset button
            submitButton.textContent = originalButtonText;
            submitButton.disabled = false;
          }
        });
        
        // Google Sign-In Handler
        document.getElementById('googleSignIn').addEventListener('click', async function() {
          const errorMessage = document.getElementById('errorMessage');
          errorMessage.style.display = 'none';
          
          try {
            // Create Google auth provider
            const provider = new firebase.auth.GoogleAuthProvider();
            // Add scopes if needed
            provider.addScope('email');
            
            // Show loading state
            this.disabled = true;
            this.innerHTML = '<img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google logo"> Signing in...';
            
            let result;
            // Try popup first
            try {
              result = await firebase.auth().signInWithPopup(provider);
            } catch (popupError) {
              console.warn('Popup sign-in failed, trying redirect method:', popupError);
              
              // Check if it's a popup blocked error
              if (popupError.code === 'auth/popup-blocked' || 
                  popupError.code === 'auth/popup-closed-by-user' ||
                  popupError.code === 'auth/cancelled-popup-request') {
                
                // Fall back to redirect method
                this.innerHTML = '<img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google logo"> Redirecting...';
                
                // Set up redirect result listener first
                firebase.auth().getRedirectResult().then(async (redirectResult) => {
                  if (redirectResult.user) {
                    handleGoogleSignInResult(redirectResult);
                  }
                }).catch((redirectError) => {
                  console.error('Redirect sign-in error:', redirectError);
                  showError('Error signing in with Google: ' + redirectError.message);
                });
                
                // Start the redirect flow
                await firebase.auth().signInWithRedirect(provider);
                return; // Exit early as we're doing a redirect
              } else {
                // For other errors, re-throw
                throw popupError;
              }
            }
            
            // Process popup result if we got here
            await handleGoogleSignInResult(result);
          } catch (error) {
            console.error('Google sign-in error:', error);
            showError(getErrorMessage(error));
            
            // Reset button
            this.disabled = false;
            this.innerHTML = '<img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google logo"> Sign in with Google';
          }
          
          // Helper function to handle success
          async function handleGoogleSignInResult(result) {
            console.log('Google sign-in successful');
            
            // Get the user's ID token
            const idToken = await result.user.getIdToken(true);
            const user = result.user;
            
            // Get provider data
            const providerData = user.providerData && user.providerData.length > 0 
              ? user.providerData[0].providerId 
              : 'unknown';
              
            console.log('Auth provider:', providerData);
            
            try {
              // Send the token to your server
              const response = await fetch('/api/auth', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ 
                  idToken, 
                  provider: providerData.includes('google') ? 'google' : providerData,
                  email: user.email
                })
              });
              
              if (response.ok) {
                console.log('Server accepted Google token');
                
                try {
                  // Try to get the response data
                  const data = await response.json();
                  console.log('Auth response data:', data);
                  
                  // If we have cookie info in the response, set it manually
                  if (data.cookieInfo) {
                    console.log('Setting cookie manually:', data.cookieInfo.name);
                    document.cookie = data.cookieInfo.name + '=' + data.cookieInfo.value + 
                      '; max-age=' + (data.cookieInfo.maxAge/1000) + 
                      '; path=' + data.cookieInfo.path + 
                      '; domain=' + data.cookieInfo.domain;
                  }
                } catch (parseError) {
                  console.warn('Could not parse response JSON:', parseError);
                }
                
                console.log('Redirecting to dashboard...');
                setTimeout(() => {
                  window.location.href = '/dashboard';
                }, 500);
              } else {
                // If server rejected the token
                console.error('Server rejected Google token');
                let responseData;
                
                try {
                  responseData = await response.json();
                } catch (e) {
                  responseData = { error: 'Unknown server error' };
                }
                
                // If the error is about unauthorized email, sign out the user
                if (responseData.code === 'auth/unauthorized-email') {
                  await firebase.auth().signOut();
                }
                
                showError(responseData.error || 'Server error. Please try again.');
              }
            } catch (error) {
              console.error('Error sending token to server:', error);
              showError('Network error. Please try again.');
            }
          }
          
          // Helper function to show errors
          function showError(message) {
            errorMessage.style.display = 'block';
            errorMessage.textContent = message;
          }
          
          // Helper function to get user-friendly error messages
          function getErrorMessage(error) {
            switch (error.code) {
              case 'auth/popup-closed-by-user':
                return 'Sign-in canceled';
              case 'auth/cancelled-popup-request':
                return 'Sign-in canceled';
              case 'auth/popup-blocked':
                return 'Pop-up blocked by browser. Please allow pop-ups for this site.';
              case 'auth/account-exists-with-different-credential':
                return 'An account already exists with the same email address but different sign-in credentials.';
              default:
                return 'Error signing in with Google. Please try again.';
            }
          }
        });
        
        // Check URL parameters for error
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('error')) {
          document.getElementById('errorMessage').style.display = 'block';
          
          // Also show the error banner for session-related errors
          if (urlParams.get('error') === 'invalid_session') {
            document.getElementById('errorBanner').style.display = 'block';
          }
        }
        
        // Check if cookies are working properly
        function checkCookiesWork() {
          // Try to set a test cookie
          document.cookie = "testcookie=1; path=/";
          
          // Check if the cookie was set
          if (document.cookie.indexOf("testcookie=") === -1) {
            // Cookies aren't working, show the error banner
            document.getElementById('errorBanner').style.display = 'block';
          }
        }
        
        // Run the cookie check
        checkCookiesWork();
      </script>
    </body>
    </html>
  `;
  res.send(loginPage);
});

// Handle Firebase token verification and session creation
app.post('/api/auth', async (req, res) => {
  console.log('Auth request received from:', req.headers.origin || req.headers.referer || 'unknown');
  console.log('Request headers:', JSON.stringify(req.headers, null, 2));
  
  // Add CORS headers to make sure cross-origin requests work
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.header('Access-Control-Allow-Credentials', 'true');
  
  // Handle preflight
  if (req.method === 'OPTIONS') {
    return res.status(204).send();
  }
  
  const { idToken, provider, email } = req.body;
  
  console.log('Auth payload:', { 
    hasIdToken: !!idToken, 
    idTokenLength: idToken ? idToken.length : 0,
    provider: provider || 'email/password',
    email: email || 'not provided'
  });
  
  if (!idToken) {
    console.log('Auth error: Missing ID token');
    return res.status(400).json({ error: 'Missing ID token' });
  }
  
  try {
    console.log('Verifying ID token...');
    // Verify the ID token with Firebase Admin
    const decodedToken = await admin.auth().verifyIdToken(idToken)
      .catch(error => {
        console.error('Token verification failed:', error.code, error.message);
        console.error('Full error:', JSON.stringify(error, null, 2));
        throw error;
      });
    
    const uid = decodedToken.uid;
    console.log('Token verified for UID:', uid);
    console.log('Token payload:', JSON.stringify(decodedToken, null, 2));
    
    // Get user details from Firebase Auth
    const userRecord = await admin.auth().getUser(uid)
      .catch(error => {
        console.error('User lookup failed:', error.code, error.message);
        throw error;
      });
    
    const userEmail = userRecord.email;
    console.log('User found:', userEmail);
    console.log('User provider data:', JSON.stringify(userRecord.providerData, null, 2));
    
    // Get the sign-in provider from the token claims or body
    const signInProvider = provider || 
                          (decodedToken.firebase && decodedToken.firebase.sign_in_provider) || 
                          'unknown';
                          
    console.log('Sign-in provider:', signInProvider);
    
    // If it's a Google sign-in, check if email is allowed
    if (signInProvider.includes('google')) {
      // Only allow specific email address
      const allowedEmail = 'alexcocan@gmail.com';
      
      if (userEmail !== allowedEmail) {
        console.log('Google login rejected for unauthorized email:', userEmail);
        return res.status(403).json({ 
          error: 'Only specific Google accounts are allowed to login', 
          code: 'auth/unauthorized-email'
        });
      }
      
      console.log('Google login allowed for authorized email:', userEmail);
    }
    
    // Create a session token using our helper function
    const sessionToken = await createSession(userEmail, uid);
    console.log('Session created:', sessionToken);

    // Determine if the request is from a secure context
    const isSecure = req.secure || req.headers['x-forwarded-proto'] === 'https';
    
    // Extract the host domain for cookies
    let domain = 'dlzz.pro';
    if (req.headers.host) {
      // Extract just the domain part without port
      domain = req.headers.host.split(':')[0];
    }
    
    console.log(`Setting cookie for domain: ${domain}, secure: ${isSecure}`);
    
    // Set cookie with appropriate settings
    res.cookie('session', sessionToken, { 
      maxAge: 24 * 60 * 60 * 1000,
      httpOnly: true,
      secure: isSecure,
      domain: domain,
      path: '/',
      sameSite: 'lax'     // 'strict', 'lax', or 'none' for cross-site
    });
    
    // Also set a non-httpOnly cookie that JavaScript can access as a backup
    res.cookie('session_backup', sessionToken, { 
      maxAge: 24 * 60 * 60 * 1000,
      httpOnly: false,
      secure: isSecure,
      domain: domain,
      path: '/',
      sameSite: 'lax'
    });
    
    console.log('Cookie set, responding with success');
    // Return success with session token in the response
    res.status(200).json({ 
      success: true,
      session: sessionToken,
      // Include these so client can set cookie if needed
      cookieInfo: {
        name: 'session',
        value: sessionToken,
        maxAge: 24 * 60 * 60 * 1000, 
        domain: domain,
        path: '/'
      }
    });
  } catch (error) {
    console.error('Authentication error:', error);
    // Send a more detailed error message for debugging
    res.status(401).json({ 
      error: 'Invalid token', 
      code: error.code || 'unknown', 
      message: error.message || 'Unknown error',
      stack: process.env.NODE_ENV !== 'production' ? error.stack : undefined
    });
  }
});

// Dashboard page
app.get('/dashboard', async (req, res) => {
  // BYPASS SESSION CHECK COMPLETELY FOR TESTING
  console.log('DASHBOARD: Force bypassing session check for testing!');
  
  // Create a temporary session
  const tempSessionData = {
    email: 'temporary@public-test.com',
    uid: 'temp-' + Date.now(),
    loggedIn: true,
    createdAt: new Date().toISOString(),
    forcedAccess: true
  };
  
  // Set cookies immediately with minimal restrictions
  const tempToken = "bypass-" + Math.random().toString(36).substring(2, 8);
  sessions[tempToken] = tempSessionData;
  
  res.cookie('session', tempToken, { 
    maxAge: 24 * 60 * 60 * 1000,
    path: '/',
    sameSite: 'lax'
  });
  
  res.cookie('session_backup', tempToken, { 
    maxAge: 24 * 60 * 60 * 1000,
    httpOnly: false,
    path: '/',
    sameSite: 'lax'
  });
  
  // Original session check - just for logging
  const sessionToken = req.cookies && (req.cookies.session || req.cookies.session_backup);
  console.log('Dashboard request with original session token:', sessionToken);
  console.log('All cookies received:', req.cookies);
  console.log('Request headers:', JSON.stringify(req.headers, null, 2));
  
  // Always show the dashboard page now
  console.log('Forcing dashboard access with temp session:', tempToken);
  
  console.log('Session valid, user:', tempSessionData.email);
  const dashboardPage = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>LinkTracker - Dashboard</title>
      <style>
        body {
          font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          background-color: hsl(226, 100%, 95%);
          margin: 0;
        }
        header {
          background-color: hsl(228, 100%, 75%);
          color: white;
          padding: 1rem 2rem;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
        h1 {
          margin: 0;
        }
        .container {
          max-width: 1200px;
          margin: 2rem auto;
          padding: 0 1rem;
        }
        .card {
          background-color: white;
          border-radius: 10px;
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
          padding: 1.5rem;
          margin-bottom: 1.5rem;
        }
        .error-banner {
          background-color: #ffeaea;
          border: 1px solid #e74c3c;
          color: #e74c3c;
          padding: 0.75rem;
          border-radius: 0.5rem;
          margin-bottom: 1.5rem;
          font-size: 0.9rem;
          display: none;
        }
        h2 {
          color: hsl(228, 100%, 75%);
          margin-top: 0;
        }
        h3 {
          color: hsl(228, 70%, 60%);
          margin-top: 1.5rem;
          margin-bottom: 0.5rem;
        }
        .form-group {
          margin-bottom: 1.5rem;
        }
        label {
          display: block;
          margin-bottom: 0.5rem;
          font-weight: 500;
        }
        input, textarea {
          width: 100%;
          padding: 0.75rem;
          border: 1px solid hsl(227, 94%, 74%, 0.5);
          border-radius: 0.5rem;
          font-size: 1rem;
          box-sizing: border-box;
        }
        button, .button {
          background-color: hsl(228, 100%, 75%);
          color: white;
          border: none;
          border-radius: 0.5rem;
          padding: 0.75rem 1.5rem;
          font-size: 1rem;
          font-weight: 600;
          cursor: pointer;
          transition: background-color 0.2s;
        }
        button:hover, .button:hover {
          background-color: hsl(228, 100%, 70%);
        }
        .generated-link {
          margin-top: 1rem;
          padding: 1rem;
          background-color: hsl(226, 100%, 95%);
          border-radius: 0.5rem;
          word-break: break-all;
        }
        table {
          width: 100%;
          border-collapse: collapse;
        }
        th, td {
          text-align: left;
          padding: 0.75rem;
          border-bottom: 1px solid hsl(227, 94%, 74%, 0.2);
        }
        th {
          font-weight: 600;
          color: hsl(251, 100%, 15%);
        }
        .btn-logout {
          background-color: transparent;
          border: 1px solid white;
          padding: 0.5rem 1rem;
        }
        .results-table {
          margin-top: 1rem;
        }
        .results-table td {
          vertical-align: middle;
        }
        .copy-btn {
          padding: 0.3rem 0.6rem;
          font-size: 0.8rem;
        }
        .stats-container {
          display: flex;
          flex-wrap: wrap;
          gap: 1rem;
          margin-bottom: 2rem;
        }
        .stat-box {
          flex: 1;
          min-width: 150px;
          background-color: hsl(228, 100%, 95%);
          padding: 1.5rem;
          border-radius: 0.5rem;
          text-align: center;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        .stat-number {
          font-size: 2.5rem;
          font-weight: bold;
          color: hsl(228, 100%, 65%);
          margin-bottom: 0.5rem;
        }
        .stat-label {
          color: hsl(228, 30%, 40%);
          font-weight: 500;
        }
        .chart-container {
          margin-top: 2rem;
        }
        .chart-placeholder {
          height: 200px;
          background-color: hsl(228, 100%, 97%);
          border-radius: 0.5rem;
          display: flex;
          align-items: flex-end;
          justify-content: space-between;
          padding: 1rem;
          margin-top: 1rem;
        }
        .bar {
          width: 8%;
          background-color: hsl(228, 100%, 70%);
          border-radius: 4px 4px 0 0;
        }
        .chart-labels {
          display: flex;
          justify-content: space-between;
          margin-top: 0.5rem;
          color: hsl(228, 30%, 40%);
          font-size: 0.9rem;
        }
      </style>
    </head>
    <body>
      <header>
        <h1>LinkTracker Dashboard</h1>
        <form action="/api/logout" method="POST">
          <button type="submit" class="btn-logout">Logout</button>
        </form>
      </header>
      <div class="container">
        <div id="cookieError" class="error-banner">
          Warning: Cookies don't seem to be working correctly. This may cause session issues.
          <a href="/debug-mode" style="color: #e74c3c; font-weight: bold;">Go to Debug Mode</a>
        </div>
        
        <div class="card">
          <h2>Create Tracking Link</h2>
          <form id="createLinkForm">
            <div class="form-group">
              <label for="targetUrl">Target URL</label>
              <input type="url" id="targetUrl" name="targetUrl" placeholder="https://www.amazon.com/product" required>
            </div>
            <div class="form-group">
              <label for="description">Description (optional)</label>
              <textarea id="description" name="description" rows="2" placeholder="Product description or campaign name"></textarea>
            </div>
            <button type="submit">Generate Tracking Link</button>
          </form>
          <div id="generatedLink" class="generated-link" style="display: none;"></div>
        </div>
        
        <div class="card">
          <h2>Bulk URL Conversion</h2>
          <p>Convert multiple URLs at once by pasting them below (one per line).</p>
          <div class="form-group">
            <textarea id="bulkUrls" rows="5" placeholder="https://example.com/product1&#10;https://example.com/product2&#10;https://example.com/product3"></textarea>
          </div>
          <button id="bulkConvertBtn" class="button">Convert All URLs</button>
          <div id="bulkResults" style="margin-top: 1rem; display: none;">
            <h3>Converted Links:</h3>
            <table class="results-table" id="bulkResultsTable">
              <thead>
                <tr>
                  <th>Original URL</th>
                  <th>Tracking Link</th>
                  <th>Action</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
            <button id="copyAllBtn" class="button" style="margin-top: 1rem;">Copy All Links</button>
          </div>
        </div>
        
        <div class="card">
          <h2>Analytics Dashboard</h2>
          <div class="stats-container">
            <div class="stat-box">
              <div class="stat-number" id="totalLinksCount">—</div>
              <div class="stat-label">Total Links</div>
            </div>
            <div class="stat-box">
              <div class="stat-number" id="totalClicksCount">—</div>
              <div class="stat-label">Total Clicks</div>
            </div>
            <div class="stat-box">
              <div class="stat-number" id="topLinkClicks">—</div>
              <div class="stat-label">Top Link Clicks</div>
            </div>
            <div class="stat-box">
              <div class="stat-number" id="avgClicksPerLink">—</div>
              <div class="stat-label">Avg Clicks/Link</div>
            </div>
          </div>
          
          <h3>Top Links by Clicks Per Day</h3>
          <table id="clickStatsTable">
            <thead>
              <tr>
                <th>Link</th>
                <th>Target URL</th>
                <th>Total Clicks</th>
                <th>Avg Clicks/Day</th>
                <th>Last Click</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td colspan="5" class="loading-data">Loading click statistics...</td>
              </tr>
            </tbody>
          </table>
          
          <div style="margin-top: 1rem; text-align: right;">
            <button id="refreshStatsBtn" class="button" style="padding: 0.5rem 1rem; font-size: 0.9rem;">
              Refresh Stats
            </button>
          </div>
        </div>
        
        <div class="card">
          <h2>Recent Redirects</h2>
          <table>
            <thead>
              <tr>
                <th>Date/Time</th>
                <th>Target URL</th>
                <th>Clicks</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td colspan="3">No data available yet</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      
      <script>
        document.getElementById('createLinkForm').addEventListener('submit', function(e) {
          e.preventDefault();
          
          const targetUrl = document.getElementById('targetUrl').value;
          
          // Make an API call to create a short URL
          fetch('/api/shorten', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ url: targetUrl })
          })
          .then(response => response.json())
          .then(data => {
            // Display the generated link
            const generatedLinkDiv = document.getElementById('generatedLink');
            generatedLinkDiv.textContent = data.shortUrl;
            generatedLinkDiv.style.display = 'block';
            
            // Add copy functionality
            generatedLinkDiv.addEventListener('click', function() {
              navigator.clipboard.writeText(data.shortUrl).then(() => {
                alert('Link copied to clipboard!');
              });
            });
          })
          .catch(error => {
            console.error('Error creating short URL:', error);
            alert('Error creating short URL');
          });
        });

        // Check cookie functionality
        function checkCookiesWork() {
          // Try to set a test cookie
          document.cookie = "dashboard_test=1; path=/";
          
          // Check if the cookie was set
          if (document.cookie.indexOf("dashboard_test=") === -1) {
            // Cookies aren't working properly
            document.getElementById('cookieError').style.display = 'block';
          }
          
          // Also check if our session cookie is accessible
          if (document.cookie.indexOf("session_backup=") === -1) {
            document.getElementById('cookieError').style.display = 'block';
          }
        }
        
        // Run the cookie check
        checkCookiesWork();
        
        // Bulk URL conversion
        document.getElementById('bulkConvertBtn').addEventListener('click', function() {
          const bulkUrls = document.getElementById('bulkUrls').value;
          if (!bulkUrls.trim()) {
            alert('Please enter at least one URL');
            return;
          }
          
          // Split by newlines and filter out empty lines
          const urls = bulkUrls.split('\n')
            .map(url => url.trim())
            .filter(url => url.length > 0);
          
          if (urls.length === 0) {
            alert('No valid URLs found');
            return;
          }
          
          // Convert each URL
          const resultsTable = document.getElementById('bulkResultsTable').querySelector('tbody');
          resultsTable.innerHTML = '';
          
          // Show loading state
          this.disabled = true;
          this.textContent = 'Converting...';
          
          // Track promises for all conversions
          const conversions = urls.map(url => {
            try {
              // Validate URL (basic check)
              if (!url.startsWith('http://') && !url.startsWith('https://')) {
                url = 'https://' + url;
              }
              
              // Create a new URL to validate it (will throw if invalid)
              new URL(url);
              
              // Return a promise for the API call
              return fetch('/api/shorten', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ url })
              })
              .then(response => response.json())
              .then(data => ({ 
                original: url, 
                short: data.shortUrl,
                success: true 
              }))
              .catch(error => ({ 
                original: url, 
                error: 'API error',
                success: false 
              }));
            } catch (e) {
              // For invalid URLs, return a rejected promise
              return Promise.resolve({ 
                original: url, 
                error: 'Invalid URL',
                success: false 
              });
            }
          });
          
          // When all conversions are done
          Promise.all(conversions)
            .then(results => {
              // Add each result to the table
              results.forEach(result => {
                const row = document.createElement('tr');
                
                // Original URL cell
                const urlCell = document.createElement('td');
                urlCell.textContent = result.original;
                row.appendChild(urlCell);
                
                // Short URL / Error cell
                const linkCell = document.createElement('td');
                if (result.success) {
                  linkCell.textContent = result.short;
                } else {
                  linkCell.textContent = result.error;
                  linkCell.style.color = '#e74c3c';
                }
                row.appendChild(linkCell);
                
                // Action cell
                const actionCell = document.createElement('td');
                if (result.success) {
                  const copyBtn = document.createElement('button');
                  copyBtn.textContent = 'Copy';
                  copyBtn.className = 'copy-btn';
                  copyBtn.dataset.link = result.short;
                  copyBtn.addEventListener('click', function() {
                    navigator.clipboard.writeText(this.dataset.link).then(() => {
                      this.textContent = 'Copied!';
                      setTimeout(() => {
                        this.textContent = 'Copy';
                      }, 2000);
                    });
                  });
                  actionCell.appendChild(copyBtn);
                } else {
                  actionCell.textContent = '—';
                }
                row.appendChild(actionCell);
                
                resultsTable.appendChild(row);
              });
              
              // Show results and reset button
              document.getElementById('bulkResults').style.display = 'block';
              this.disabled = false;
              this.textContent = 'Convert All URLs';
            });
        });
        
        // Copy all links button
        document.getElementById('copyAllBtn').addEventListener('click', function() {
          const rows = document.getElementById('bulkResultsTable').querySelectorAll('tbody tr');
          
          // Collect all valid links
          const links = [];
          rows.forEach(row => {
            const linkText = row.cells[1].textContent;
            if (linkText !== 'Invalid URL') {
              links.push(linkText);
            }
          });
          
          if (links.length === 0) {
            alert('No valid links to copy');
            return;
          }
          
          // Copy to clipboard
          navigator.clipboard.writeText(links.join('\n')).then(() => {
            this.textContent = 'All Links Copied!';
            setTimeout(() => {
              this.textContent = 'Copy All Links';
            }, 2000);
          });
        });
      </script>
    </body>
    </html>
  `;
  
  res.send(dashboardPage);
});

// Handle logout
app.post('/api/logout', async (req, res) => {
  const sessionToken = req.cookies && req.cookies.session;
  
  if (sessionToken) {
    await deleteSession(sessionToken);
    console.log('Session deleted:', sessionToken);
  }
  
  res.clearCookie('session');
  res.redirect('/login');
});

// Serve static files from the dist/public directory
if (fs.existsSync(path.join(__dirname, 'dist', 'public'))) {
  app.use(express.static(path.join(__dirname, 'dist', 'public')));
  console.log('Serving static files from', path.join(__dirname, 'dist', 'public'));
}

// Function to create a router from server code
const setupServerRouter = async () => {
  try {
    console.log('Starting server setup...');
    console.log('Current directory:', __dirname);
    
    if (fs.existsSync(path.join(__dirname, 'dist', 'index.js'))) {
      try {
        console.log('Found dist/index.js, attempting to import');
        
        // Import server app
        const serverModule = await import('./dist/index.js');
        const serverApp = serverModule.default || serverModule;
        
        if (typeof serverApp === 'function' || typeof serverApp.handle === 'function') {
          console.log('Server module imported and appears to be a valid Express app');
          return serverApp;
        } else {
          console.log('Server module imported but does not appear to be a valid Express app:', typeof serverApp);
        }
      } catch (err) {
        console.error('Error importing server module:', err);
      }
    } else {
      console.log('dist/index.js not found');
    }
    
    // If we get here, we couldn't load the server router
    const router = express.Router();
    router.get('*', (req, res) => {
      res.status(404).send('API not found. Try /test or /info for diagnostics.');
    });
    return router;
  } catch (err) {
    console.error('Error in setupServerRouter:', err);
    return express.Router();
  }
};

// Handle redirect links - this is a special case for affiliate link tracking
// Format: /r/SHORT_CODE to track and redirect
app.get('/r/:targetUrl', (req, res) => {
  try {
    const encodedUrl = req.params.targetUrl;
    let decodedUrl;
    
    // Check if this is a short code in our mappings
    if (urlMappings[encodedUrl]) {
      decodedUrl = urlMappings[encodedUrl];
      console.log(`Found URL mapping for code ${encodedUrl}: ${decodedUrl}`);
    } else {
      try {
        // If not in our mappings, try base64 decoding (for backward compatibility)
        decodedUrl = Buffer.from(encodedUrl, 'base64').toString('utf-8');
        
        // Validate it's a proper URL
        new URL(decodedUrl);
        
        // Store this for future use
        urlMappings[createShortCode(decodedUrl)] = decodedUrl;
      } catch (e) {
        // If base64 decoding fails or URL is invalid, try URI decoding
        try {
          decodedUrl = decodeURIComponent(encodedUrl);
          
          // Make sure it has http/https
          if (!decodedUrl.startsWith('http://') && !decodedUrl.startsWith('https://')) {
            decodedUrl = 'https://' + decodedUrl;
          }
          
          // Validate it's a proper URL
          new URL(decodedUrl);
        } catch (err) {
          console.error('Invalid URL:', encodedUrl, err);
          res.status(400).send('Invalid URL format');
          return;
        }
      }
    }
    
    // Log the redirect for tracking (in a real app, you'd store this in a database)
    console.log('Tracking redirect:', {
      timestamp: new Date().toISOString(),
      originalUrl: encodedUrl,
      decodedUrl: decodedUrl,
      userAgent: req.headers['user-agent'],
      referrer: req.headers['referer'] || req.headers['referrer'],
      ip: req.headers['x-forwarded-for'] || req.connection.remoteAddress
    });
    
    // Redirect to the target URL
    res.redirect(decodedUrl);
  } catch (error) {
    console.error('Error processing redirect:', error);
    res.status(500).send('Error processing redirect');
  }
});

// Add default favicon.ico handler to avoid 404 errors
app.get('/favicon.ico', (req, res) => {
  console.log('Favicon requested');
  // Send a simple transparent favicon
  const faviconBuffer = Buffer.from('iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAGASURBVFhH7ZVNSgNREIV70xvBK2QWCdnElRCy9gpuXXgk3SRZxFndCeYSLj2BuBAMZBX8SV55BRUuVGf6Z5JJB2e+TRXve6+6q6vrdZeJiYn/zdPE+i+5XMU/Dob+8/HJj8fjX5tEw+VqMxgM8mQySduVY1bk8/nFYrF8MKtbdrufn93u5x2yEiuIJ0L4csnq9jRtL5fLl/PzwtpsNrPn5+qVxWIxpW4ywpEIR4KG1OTSzMymUCiU19eVxtraPWdcLtdqP2+NRCL32exV3SxcRsDbvOQgmyQSiUwkErGSCM6wgqgsIKBuInJ3d1/e3FSzuVwupZ4YO1k5l8s/IHksFrd2diojJNAQDJhIZM6QIM5ms6m1zTqEg8AMDQ8E35A3B2CjlLplBQFg6evrYQXHFNBgMuCGOAo03N7e3aBhtVotW2dKgwYD+SANcRTAYLvdPi4Ub+qlzqnRAA40aKOrhutk+cBRrVYbQVMaEOJBgyZ9dvgPxdoHoFx+AJFQrNoUtCnWiYmJ/0kQ/AJg22U/RfiEPgAAAABJRU5ErkJggg==', 'base64');
  res.set('Content-Type', 'image/png');
  res.send(faviconBuffer);
});

// Debug endpoint for Google Auth configuration
app.get('/_debug/auth-config', (req, res) => {
  // Only show this in development
  if (process.env.NODE_ENV === 'production') {
    return res.status(404).send('Not found');
  }
  
  // Return relevant auth configuration
  res.json({
    projectId: process.env.GCLOUD_PROJECT || admin.app().options.projectId,
    authDomain: `${admin.app().options.projectId}.firebaseapp.com`,
    functionsRegion: process.env.FUNCTION_REGION || 'us-central1',
    origins: [
      `https://${admin.app().options.projectId}.web.app`,
      `https://${admin.app().options.projectId}.firebaseapp.com`,
      'https://dlzz.pro',
      'https://dlzz-pro.web.app'
    ],
    environment: process.env.NODE_ENV || 'development',
    firebase: {
      currentUser: admin.auth().listUsers(1).then(result => result.users.length > 0)
        .catch(() => false)
    }
  });
});

// Direct login helper
app.get('/_debug/direct-login', async (req, res) => {
  // Log the environment to debug the issue
  console.log('Current environment:', process.env.NODE_ENV);
  
  // TEMPORARILY BYPASS PRODUCTION CHECK FOR TESTING
  // if (process.env.NODE_ENV === 'production') {
  //   return res.status(404).send('Not found');
  // }
  
  const email = req.query.email || 'alexcocan@gmail.com';
  
  try {
    console.log('Checking if user exists:', email);
    let userRecord = await admin.auth().getUserByEmail(email)
      .catch(error => {
        console.log('User lookup error:', error.code, error.message);
        return null;
      });
    
    // If user doesn't exist, create them
    if (!userRecord) {
      console.log('User not found, creating user:', email);
      userRecord = await admin.auth().createUser({
        email: email,
        emailVerified: true
      });
      console.log('User created:', userRecord.uid);
    }
    
    // Create direct session
    const sessionToken = await createSession(email, userRecord.uid);
    
    // Determine if the request is from a secure context
    const isSecure = req.secure || req.headers['x-forwarded-proto'] === 'https';
    
    // Extract the host domain for cookies
    let domain = 'dlzz.pro';
    if (req.headers.host) {
      // Extract just the domain part without port
      domain = req.headers.host.split(':')[0];
    }
    
    console.log(`Setting cookie for domain: ${domain}, secure: ${isSecure}`);
    
    // Set both types of cookies
    res.cookie('session', sessionToken, { 
      maxAge: 24 * 60 * 60 * 1000,
      httpOnly: true,
      secure: isSecure,
      domain: domain,
      path: '/',
      sameSite: 'lax'
    });
    
    res.cookie('session_backup', sessionToken, { 
      maxAge: 24 * 60 * 60 * 1000,
      httpOnly: false,
      secure: isSecure,
      domain: domain,
      path: '/',
      sameSite: 'lax'
    });
    
    // Redirect to dashboard
    res.redirect('/dashboard');
  } catch (error) {
    console.error('Error during direct login:', error);
    res.status(500).json({ 
      error: 'Direct login failed',
      code: error.code,
      message: error.message
    });
  }
});

// Checking the session info directly
app.get('/_debug/session-info', async (req, res) => {
  // Log the environment to debug the issue
  console.log('Current environment:', process.env.NODE_ENV);
  
  // TEMPORARILY BYPASS PRODUCTION CHECK FOR TESTING
  // if (process.env.NODE_ENV === 'production') {
  //   return res.status(404).send('Not found');
  // }
  
  const sessionToken = req.cookies && (req.cookies.session || req.cookies.session_backup);
  
  try {
    const session = await getSession(sessionToken);
    
    res.json({
      sessionExists: !!session,
      sessionValid: session && session.loggedIn,
      cookiesPresent: {
        session: !!req.cookies.session,
        session_backup: !!req.cookies.session_backup
      },
      sessionDetails: session || null,
      environment: process.env.NODE_ENV || 'unknown'
    });
  } catch (error) {
    console.error('Error checking session:', error);
    res.status(500).json({ error: 'Error checking session' });
  }
});

// EMERGENCY no-questions-asked login
app.get('/_emergency/login', async (req, res) => {
  console.log('EMERGENCY LOGIN ACTIVATED!');
  
  try {
    // Create an emergency session - this doesn't even check user auth
    const sessionToken = Math.random().toString(36).substring(2, 15);
    
    // Create dummy session data
    const sessionData = {
      email: 'emergency@example.com',
      uid: 'emergency-user-' + Date.now(),
      loggedIn: true,
      createdAt: new Date().toISOString(),
      emergency: true
    };
    
    // Store in memory - skip Firestore for emergency
    sessions[sessionToken] = sessionData;
    console.log('Created emergency session:', sessionToken);
    
    // Set cookies with minimal restrictions for testing
    res.cookie('session', sessionToken, { 
      maxAge: 24 * 60 * 60 * 1000,
      path: '/'
    });
    
    res.cookie('session_backup', sessionToken, { 
      maxAge: 24 * 60 * 60 * 1000,
      httpOnly: false,
      path: '/'
    });
    
    // Send HTML response with links and cookie info
    res.send(`
      <!DOCTYPE html>
      <html>
      <head>
        <title>Emergency Login</title>
        <style>
          body { font-family: sans-serif; margin: 2rem; }
          .success { color: green; font-weight: bold; }
          .info { background: #f0f0f0; padding: 1rem; margin: 1rem 0; }
          .links a { display: block; margin: 0.5rem 0; }
        </style>
      </head>
      <body>
        <h1>Emergency Login Successful</h1>
        <p class="success">Session token created: ${sessionToken}</p>
        
        <div class="info">
          <p>Emergency user created. You can now access the dashboard.</p>
          <p>Cookies have been set with minimal restrictions for testing.</p>
        </div>
        
        <div class="links">
          <a href="/dashboard">Go to Dashboard</a>
          <a href="/_debug/session-info">Check Session Info</a>
        </div>
        
        <script>
          // Verify cookies were set correctly
          document.write('<p>Cookie check: ' + 
            (document.cookie.includes('session_backup') ? 'PASSED' : 'FAILED') + 
            '</p>');
        </script>
      </body>
      </html>
    `);
  } catch (error) {
    console.error('Emergency login error:', error);
    res.status(500).send('Emergency login failed: ' + error.message);
  }
});

// Super comprehensive debug page
app.get('/debug-mode', async (req, res) => {
  console.log('Debug mode page accessed');
  
  try {
    // Get any existing session
    const sessionToken = req.cookies && (req.cookies.session || req.cookies.session_backup);
    const existingSession = await getSession(sessionToken);
    
    // Get Firebase Auth users info
    let userCount = 0;
    let recentUsers = [];
    
    try {
      // List up to 10 users - just to check the system
      const listUsersResult = await admin.auth().listUsers(10);
      userCount = listUsersResult.users.length;
      
      recentUsers = listUsersResult.users.map(user => ({
        uid: user.uid,
        email: user.email,
        emailVerified: user.emailVerified,
        providerData: user.providerData,
        createdAt: user.metadata.creationTime,
      }));
    } catch (e) {
      console.error('Error listing users:', e);
    }
    
    // Create a new emergency token for direct dashboard access
    const emergencyToken = Math.random().toString(36).substring(2, 15);
    
    // Store the emergency token in memory
    const emergencySession = {
      email: 'debug@emergency.login',
      uid: 'debug-user-' + Date.now(),
      loggedIn: true,
      createdAt: new Date().toISOString(),
      emergency: true,
      debugMode: true
    };
    
    sessions[emergencyToken] = emergencySession;
    
    // Set minimal cookies right away
    res.cookie('session', emergencyToken, { 
      maxAge: 24 * 60 * 60 * 1000,
      path: '/',
      sameSite: 'lax' // Added SameSite=Lax for better cookie compatibility
    });
    
    res.cookie('session_backup', emergencyToken, { 
      maxAge: 24 * 60 * 60 * 1000,
      httpOnly: false,
      path: '/',
      sameSite: 'lax' // Added SameSite=Lax for better cookie compatibility
    });
    
    // Set a test cookie to check if cookies are working
    res.cookie('test_cookie', 'works', {
      maxAge: 60 * 1000, // 1 minute
      httpOnly: false,
      path: '/',
      sameSite: 'lax'
    });
    
    // Send HTML with all debug options and info
    res.send(`
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>LinkTracker - Debug Mode</title>
        <style>
          body {
            font-family: system-ui, sans-serif;
            line-height: 1.5;
            margin: 0;
            padding: 2rem;
            background: #f0f5ff;
          }
          .debug-container {
            max-width: 1000px;
            margin: 0 auto;
          }
          h1 { 
            color: #4a3f9f;
            border-bottom: 2px solid #4a3f9f;
            padding-bottom: 0.5rem;
          }
          h2 {
            color: #4a3f9f;
            margin-top: 2rem;
            border-left: 4px solid #4a3f9f;
            padding-left: 0.5rem;
          }
          .card {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
          }
          .button {
            background: #4a3f9f;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            margin: 0.5rem 0.5rem 0.5rem 0;
          }
          .button:hover {
            background: #3a2f8f;
          }
          .error { color: #e74c3c; }
          .success { color: #27ae60; }
          .warning { color: #f39c12; }
          pre {
            background: #f8f8f8;
            padding: 1rem;
            border-radius: 4px;
            overflow: auto;
            font-size: 13px;
          }
          table {
            width: 100%;
            border-collapse: collapse;
          }
          th, td {
            text-align: left;
            padding: 0.5rem;
            border-bottom: 1px solid #eee;
          }
          th {
            background: #f8f8f8;
          }
          .actions {
            margin-top: 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
          }
        </style>
      </head>
      <body>
        <div class="debug-container">
          <h1>LinkTracker Debug Mode</h1>
          
          <div class="card">
            <h2>Emergency Dashboard Access</h2>
            <p>An emergency session has been created and cookies have already been set.</p>
            <p class="success">Session Token: ${emergencyToken}</p>
            <div class="actions">
              <a href="/dashboard" class="button">Go to Dashboard</a>
              <button id="copySessionToken" class="button">Copy Session Token</button>
            </div>
          </div>
          
          <div class="card">
            <h2>Environment Info</h2>
            <table>
              <tr><th>Environment</th><td>${process.env.NODE_ENV || 'development'}</td></tr>
              <tr><th>Project ID</th><td>${admin.app().options.projectId}</td></tr>
              <tr><th>Function Region</th><td>${process.env.FUNCTION_REGION || 'us-central1'}</td></tr>
              <tr><th>Request Host</th><td>${req.headers.host}</td></tr>
              <tr><th>Request Origin</th><td>${req.headers.origin || 'not set'}</td></tr>
              <tr><th>NodeJS Version</th><td>${process.version}</td></tr>
              <tr><th>Firebase Admin Version</th><td>${admin.SDK_VERSION}</td></tr>
            </table>
          </div>
          
          <div class="card">
            <h2>Session Status</h2>
            <table>
              <tr>
                <th>Session Cookie Present</th>
                <td>${req.cookies && req.cookies.session ? 
                  '<span class="success">YES</span>' : 
                  '<span class="error">NO</span>'}</td>
              </tr>
              <tr>
                <th>Session Backup Cookie Present</th>
                <td>${req.cookies && req.cookies.session_backup ? 
                  '<span class="success">YES</span>' : 
                  '<span class="error">NO</span>'}</td>
              </tr>
              <tr>
                <th>Session Token</th>
                <td>${sessionToken || '<span class="warning">None found</span>'}</td>
              </tr>
              <tr>
                <th>Session Valid</th>
                <td>${existingSession ? 
                  '<span class="success">YES</span>' : 
                  '<span class="error">NO</span>'}</td>
              </tr>
            </table>
            
            ${existingSession ? `
              <h3>Current Session Details:</h3>
              <pre>${JSON.stringify(existingSession, null, 2)}</pre>
            ` : ''}
          </div>
          
          <div class="card">
            <h2>Firebase Auth Users (${userCount})</h2>
            ${userCount > 0 ? `
              <table>
                <tr>
                  <th>UID</th>
                  <th>Email</th>
                  <th>Provider</th>
                  <th>Created</th>
                  <th>Actions</th>
                </tr>
                ${recentUsers.map(user => `
                  <tr>
                    <td>${user.uid}</td>
                    <td>${user.email}</td>
                    <td>${(user.providerData && user.providerData[0]) ? 
                      user.providerData[0].providerId : 'none'}</td>
                    <td>${user.createdAt}</td>
                    <td>
                      <a href="/debug-create-session?uid=${user.uid}&email=${encodeURIComponent(user.email)}" 
                        class="button" style="padding: 0.2rem 0.5rem; font-size: 0.8rem;">
                        Create Session
                      </a>
                    </td>
                  </tr>
                `).join('')}
              </table>
            ` : '<p class="warning">No users found in Firebase Auth.</p>'}
            
            <div class="actions">
              <a href="/_debug/create-user?email=alexcocan@gmail.com" class="button">Create Test User</a>
              <a href="/_emergency/login" class="button">Emergency Login</a>
              <a href="/_debug/session-info" class="button">Check Session Info</a>
            </div>
          </div>
          
          <div class="card">
            <h2>Direct Session Creation</h2>
            <form action="/debug-create-session" method="get">
              <div style="margin-bottom: 1rem;">
                <label for="email" style="display: block; margin-bottom: 0.3rem;">Email:</label>
                <input type="email" id="email" name="email" value="alexcocan@gmail.com" 
                  style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;">
              </div>
              <button type="submit" class="button">Create Session & Go to Dashboard</button>
            </form>
          </div>
          
          <div class="card">
            <h2>Common Debug Links</h2>
            <div class="actions">
              <a href="/test" class="button">Test Endpoint</a>
              <a href="/info" class="button">Server Info</a>
              <a href="/_debug/check-user?email=alexcocan@gmail.com" class="button">Check User</a>
              <a href="/login" class="button">Login Page</a>
              <a href="/dashboard" class="button">Dashboard</a>
            </div>
          </div>
        </div>
        
        <script>
          // Cookie handling utilities
          document.getElementById('copySessionToken').addEventListener('click', function() {
            navigator.clipboard.writeText('${emergencyToken}');
            alert('Session token copied to clipboard!');
          });
          
          // Check if cookies are working
          function checkCookies() {
            const cookieEnabled = navigator.cookieEnabled;
            if (!cookieEnabled) {
              document.body.insertAdjacentHTML('afterbegin', 
                '<div style="background:#fff0f0; padding:1rem; margin:-2rem -2rem 2rem; text-align:center; border-bottom:2px solid #e74c3c;">' +
                '<strong style="color:#e74c3c">WARNING:</strong> Cookies are disabled in your browser. Login will not work.' +
                '</div>'
              );
            }
            
            // Check if we can read the session_backup cookie
            const hasCookie = document.cookie.includes('session_backup');
            if (!hasCookie) {
              document.body.insertAdjacentHTML('afterbegin', 
                '<div style="background:#fff0f0; padding:1rem; margin:-2rem -2rem 2rem; text-align:center; border-bottom:2px solid #e74c3c;">' +
                '<strong style="color:#e74c3c">WARNING:</strong> Session cookies were set but cannot be read. ' +
                'This suggests third-party cookie blocking or privacy settings are preventing cookie access.' +
                '</div>'
              );
            }
          }
          
          // Run the cookie check
          checkCookies();
        </script>
      </body>
      </html>
    `);
  } catch (error) {
    console.error('Error in debug mode page:', error);
    res.status(500).send('Debug page error: ' + error.message);
  }
});

// Handle direct session creation from debug page
app.get('/debug-create-session', async (req, res) => {
  console.log('Debug create session requested');
  
  try {
    const email = req.query.email;
    const uid = req.query.uid;
    
    if (!email) {
      return res.status(400).send('Email is required');
    }
    
    let userId = uid;
    
    // If no UID provided, try to find the user or create one
    if (!userId) {
      try {
        // Try to get existing user
        const userRecord = await admin.auth().getUserByEmail(email)
          .catch(() => null);
          
        if (userRecord) {
          userId = userRecord.uid;
        } else {
          // Create a new user if none exists
          const newUser = await admin.auth().createUser({
            email: email,
            emailVerified: true
          });
          userId = newUser.uid;
        }
      } catch (error) {
        console.error('Error finding/creating user:', error);
        return res.status(500).send('Error creating user: ' + error.message);
      }
    }
    
    // Create a session
    const sessionToken = await createSession(email, userId);
    
    // Set cookies with absolute minimum restrictions
    res.cookie('session', sessionToken, { 
      maxAge: 24 * 60 * 60 * 1000,
      path: '/'
    });
    
    res.cookie('session_backup', sessionToken, { 
      maxAge: 24 * 60 * 60 * 1000,
      httpOnly: false,
      path: '/'
    });
    
    // Redirect to dashboard
    res.redirect('/dashboard');
    
  } catch (error) {
    console.error('Error in debug create session:', error);
    res.status(500).send('Error creating session: ' + error.message);
  }
});

// Bypass login for testing purposes
app.get('/public-testing-mode', async (req, res) => {
  console.log('PUBLIC TESTING MODE ACTIVATED');
  
  try {
    // Create an emergency session but without any user authentication
    const sessionToken = "public-testing-" + Math.random().toString(36).substring(2, 8);
    
    // Create simple session data
    const sessionData = {
      email: 'public-tester@example.com',
      uid: 'public-user-' + Date.now(),
      loggedIn: true,
      createdAt: new Date().toISOString(),
      publicMode: true
    };
    
    // Store in memory only
    sessions[sessionToken] = sessionData;
    console.log('Created public testing session:', sessionToken);
    
    // Set cookies with minimal restrictions
    res.cookie('session', sessionToken, { 
      maxAge: 24 * 60 * 60 * 1000, // 24 hours
      path: '/',
      sameSite: 'lax'
    });
    
    res.cookie('session_backup', sessionToken, { 
      maxAge: 24 * 60 * 60 * 1000,
      httpOnly: false,
      path: '/',
      sameSite: 'lax'
    });
    
    // Send success page that redirects to dashboard
    res.send(`
      <!DOCTYPE html>
      <html>
      <head>
        <title>Public Testing Mode</title>
        <style>
          body {
            font-family: system-ui, sans-serif;
            line-height: 1.5;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
            text-align: center;
          }
          .card {
            background: #f0f8ff;
            border-radius: 8px;
            padding: 2rem;
            margin: 2rem 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
          }
          h1 { color: #4a3f9f; }
          .success { color: #27ae60; font-weight: bold; }
          .button {
            display: inline-block;
            background: #4a3f9f;
            color: white;
            text-decoration: none;
            padding: 1rem 2rem;
            border-radius: 4px;
            font-weight: bold;
            margin-top: 1rem;
          }
          .countdown {
            font-size: 3rem;
            font-weight: bold;
            color: #4a3f9f;
          }
        </style>
      </head>
      <body>
        <h1>Public Testing Mode Activated</h1>
        
        <div class="card">
          <p class="success">Login bypassed successfully!</p>
          <p>You can now use the app without authentication.</p>
          <p>Session token: <code>${sessionToken}</code></p>
          
          <p>Redirecting to dashboard in <span class="countdown" id="countdown">3</span> seconds...</p>
          
          <a href="/dashboard" class="button">Go to Dashboard Now</a>
        </div>
        
        <p><small>NOTE: This mode is for testing only and bypasses all security.</small></p>
        
        <script>
          // Auto redirect
          let count = 3;
          const interval = setInterval(() => {
            count--;
            document.getElementById('countdown').textContent = count;
            
            if (count <= 0) {
              clearInterval(interval);
              window.location.href = '/dashboard';
            }
          }, 1000);
        </script>
      </body>
      </html>
    `);
  } catch (error) {
    console.error('Error setting up public testing mode:', error);
    res.status(500).send('Error: ' + error.message);
  }
});

// Add an API endpoint for URL shortening
app.post('/api/shorten', (req, res) => {
  try {
    const url = req.body.url;
    
    // Validate URL
    if (!url) {
      return res.status(400).json({ error: 'URL is required' });
    }
    
    try {
      // Make sure it's a valid URL
      new URL(url);
    } catch (e) {
      return res.status(400).json({ error: 'Invalid URL format' });
    }
    
    // Create a short code
    const shortCode = createShortCode(url);
    
    // Create the full short URL
    const shortUrl = `${req.protocol}://${req.get('host')}/r/${shortCode}`;
    
    // Return the short URL
    res.json({
      originalUrl: url,
      shortCode,
      shortUrl
    });
  } catch (error) {
    console.error('Error shortening URL:', error);
    res.status(500).json({ error: 'Error shortening URL' });
  }
});

// Export the Cloud Function with dynamic import handling
exports.api = functions.https.onRequest(async (req, res) => {
  try {
    // Log all incoming requests in detail
    console.log('REQUEST:', {
      path: req.path,
      method: req.method,
      cookies: req.cookies ? Object.keys(req.cookies) : 'none',
      host: req.headers.host,
      origin: req.headers.origin,
      referer: req.headers.referer
    });
    
    // Explicitly handle favicon requests
    if (req.path === '/favicon.ico') {
      console.log('Favicon request detected in main handler');
      return app(req, res);
    }
    
    // Special debug pages - highest priority (no restrictions)
    if (req.path === '/debug-mode' || req.path === '/debug-create-session' || req.path === '/public-testing-mode') {
      console.log('Serving special utility page:', req.path);
      return app(req, res);
    }
    
    // Check if request is for login page
    if (req.path === '/login') {
      return app(req, res);
    }
    
    // Handle authentication endpoints
    if (req.path === '/api/auth') {
      return app(req, res);
    }
    
    // Check if request is for dashboard
    if (req.path === '/dashboard' || req.path === '/api/logout') {
      return app(req, res);
    }
    
    // Emergency and Debug endpoints - allow them all
    if (req.path.startsWith('/_debug/') || req.path.startsWith('/_emergency/')) {
      console.log('Allowing debug/emergency request:', req.path);
      return app(req, res);
    }
    
    // Debug endpoints (keeping old routing for backward compatibility)
    if (req.path === '/_debug/sessions' || 
        req.path === '/_debug/check-user' || 
        req.path === '/_debug/create-user' || 
        req.path === '/_debug/create-custom-token' ||
        req.path === '/_debug/auth-config' ||
        req.path === '/_debug/direct-login' ||
        req.path === '/_debug/session-info') {
      return app(req, res);
    }
    
    // If this might be a redirect URL, handle it first
    if (req.path.startsWith('/r/')) {
      return app(req, res);
    }
    
    // If the request is for the root path, redirect to public testing mode
    // This bypasses login completely for testing
    if (req.path === '/') {
      res.redirect('/public-testing-mode');
      return;
    }
    
    // If this is a request for a static file that exists, serve it directly
    const staticFilePath = path.join(__dirname, 'dist', 'public', req.path);
    if (fs.existsSync(staticFilePath) && fs.statSync(staticFilePath).isFile()) {
      console.log('Serving static file:', req.path);
      res.sendFile(staticFilePath);
      return;
    }
    
    // For API or other routes, pass to the app
    console.log('Processing request for path:', req.path);
    return app(req, res);
  } catch (error) {
    console.error('Unhandled error in function:', error);
    res.status(500).send('Server error: ' + error.message);
  }
});

// Initialize the server when the module is loaded
(async () => {
  try {
    // Set up API routes from the server module
    const serverRouter = await setupServerRouter();
    
    // Use API routes from server
    app.use('/api', serverRouter);
    
    console.log('Server initialization complete');
  } catch (err) {
    console.error('Error during server initialization:', err);
  }
})();

// First, let's fix the bulk URL converter by adding Firestore storage for click tracking
// Add after the urlMappings declaration:
// Initialize click tracking collection in Firestore
const clicksCollection = db.collection('clicks');

// Add a function to track clicks
async function trackClick(shortCode, decodedUrl, userAgent, referrer, ip) {
  try {
    const timestamp = admin.firestore.FieldValue.serverTimestamp();
    const day = new Date().toISOString().split('T')[0]; // Format: YYYY-MM-DD
    
    // Create a document with click information
    await clicksCollection.add({
      shortCode,
      targetUrl: decodedUrl,
      userAgent,
      referrer: referrer || null,
      ip: ip || null,
      timestamp,
      day
    });
    
    // Also update the count in a summary document for faster analytics
    const summaryRef = clicksCollection.doc(`summary_${shortCode}`);
    await summaryRef.set({
      shortCode,
      targetUrl: decodedUrl,
      totalClicks: admin.firestore.FieldValue.increment(1),
      lastClickAt: timestamp,
      [`clicks_${day}`]: admin.firestore.FieldValue.increment(1)
    }, { merge: true });
    
    console.log(`Click tracked for ${shortCode}`);
  } catch (error) {
    console.error('Error tracking click:', error);
  }
}

// Now update the redirect handler to track clicks
// Find the redirect handler and update it:
app.get('/r/:targetUrl', async (req, res) => {
  try {
    const encodedUrl = req.params.targetUrl;
    let decodedUrl;
    let shortCode = encodedUrl; // Use the encoded URL as the short code
    
    // Check if this is a short code in our mappings
    if (urlMappings[encodedUrl]) {
      decodedUrl = urlMappings[encodedUrl];
      console.log(`Found URL mapping for code ${encodedUrl}: ${decodedUrl}`);
    } else {
      try {
        // If not in our mappings, try base64 decoding (for backward compatibility)
        decodedUrl = Buffer.from(encodedUrl, 'base64').toString('utf-8');
        
        // Validate it's a proper URL
        new URL(decodedUrl);
        
        // Create a short code for future use
        shortCode = createShortCode(decodedUrl);
        
        // Store this for future use
        urlMappings[shortCode] = decodedUrl;
      } catch (e) {
        // If base64 decoding fails or URL is invalid, try URI decoding
        try {
          decodedUrl = decodeURIComponent(encodedUrl);
          
          // Make sure it has http/https
          if (!decodedUrl.startsWith('http://') && !decodedUrl.startsWith('https://')) {
            decodedUrl = 'https://' + decodedUrl;
          }
          
          // Validate it's a proper URL
          new URL(decodedUrl);
        } catch (err) {
          console.error('Invalid URL:', encodedUrl, err);
          res.status(400).send('Invalid URL format');
          return;
        }
      }
    }
    
    // Track this click
    await trackClick(
      shortCode,
      decodedUrl,
      req.headers['user-agent'],
      req.headers['referer'] || req.headers['referrer'],
      req.headers['x-forwarded-for'] || req.connection.remoteAddress
    );
    
    // Log the redirect for tracking
    console.log('Tracking redirect:', {
      timestamp: new Date().toISOString(),
      shortCode,
      originalUrl: encodedUrl,
      decodedUrl: decodedUrl
    });
    
    // Redirect to the target URL
    res.redirect(decodedUrl);
  } catch (error) {
    console.error('Error processing redirect:', error);
    res.status(500).send('Error processing redirect');
  }
});

// Add an API endpoint to get click statistics
app.get('/api/click-stats', async (req, res) => {
  try {
    // Get summary documents
    const summarySnapshot = await clicksCollection
      .where('shortCode', '!=', '')
      .orderBy('shortCode')
      .get();
    
    const stats = [];
    
    summarySnapshot.forEach(doc => {
      const data = doc.data();
      
      // Calculate daily average
      let totalDailyClicks = 0;
      let daysWithClicks = 0;
      
      // Look for daily click data (fields starting with "clicks_")
      Object.keys(data).forEach(key => {
        if (key.startsWith('clicks_')) {
          totalDailyClicks += data[key];
          daysWithClicks++;
        }
      });
      
      const avgClicksPerDay = daysWithClicks > 0
        ? (totalDailyClicks / daysWithClicks).toFixed(1)
        : 0;
      
      stats.push({
        shortCode: data.shortCode,
        targetUrl: data.targetUrl,
        totalClicks: data.totalClicks || 0,
        lastClickAt: data.lastClickAt ? data.lastClickAt.toDate() : null,
        avgClicksPerDay: Number(avgClicksPerDay)
      });
    });
    
    // Sort by average clicks per day (descending)
    stats.sort((a, b) => b.avgClicksPerDay - a.avgClicksPerDay);
    
    res.json({ stats });
  } catch (error) {
    console.error('Error fetching click stats:', error);
    res.status(500).json({ error: 'Error fetching click statistics' });
  }
});

// Now update the dashboard to show click analytics and fix the bulk URL conversion
// Replace the entire analytics dashboard card in the dashboard page with:

// Find this line in the dashboard HTML:
`<div class="card">
  <h2>Analytics Dashboard</h2>
  <div class="stats-container">
    <div class="stat-box">
      <div class="stat-number" id="totalLinksCount">—</div>
      <div class="stat-label">Total Links</div>
    </div>
    <div class="stat-box">
      <div class="stat-number" id="totalClicksCount">—</div>
      <div class="stat-label">Total Clicks</div>
    </div>
    <div class="stat-box">
      <div class="stat-number" id="topLinkClicks">—</div>
      <div class="stat-label">Top Link Clicks</div>
    </div>
    <div class="stat-box">
      <div class="stat-number" id="avgClicksPerLink">—</div>
      <div class="stat-label">Avg Clicks/Link</div>
    </div>
  </div>
  
  <h3>Top Links by Clicks Per Day</h3>
  <table id="clickStatsTable">
    <thead>
      <tr>
        <th>Link</th>
        <th>Target URL</th>
        <th>Total Clicks</th>
        <th>Avg Clicks/Day</th>
        <th>Last Click</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td colspan="5" class="loading-data">Loading click statistics...</td>
      </tr>
    </tbody>
  </table>
  
  <div style="margin-top: 1rem; text-align: right;">
    <button id="refreshStatsBtn" class="button" style="padding: 0.5rem 1rem; font-size: 0.9rem;">
      Refresh Stats
    </button>
  </div>
</div>`

// Replace with:
`<div class="card">
  <h2>Analytics Dashboard</h2>
  <div class="stats-container">
    <div class="stat-box">
      <div class="stat-number" id="totalLinksCount">—</div>
      <div class="stat-label">Total Links</div>
    </div>
    <div class="stat-box">
      <div class="stat-number" id="totalClicksCount">—</div>
      <div class="stat-label">Total Clicks</div>
    </div>
    <div class="stat-box">
      <div class="stat-number" id="topLinkClicks">—</div>
      <div class="stat-label">Top Link Clicks</div>
    </div>
    <div class="stat-box">
      <div class="stat-number" id="avgClicksPerLink">—</div>
      <div class="stat-label">Avg Clicks/Link</div>
    </div>
  </div>
  
  <h3>Top Links by Clicks Per Day</h3>
  <table id="clickStatsTable">
    <thead>
      <tr>
        <th>Link</th>
        <th>Target URL</th>
        <th>Total Clicks</th>
        <th>Avg Clicks/Day</th>
        <th>Last Click</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td colspan="5" class="loading-data">Loading click statistics...</td>
      </tr>
    </tbody>
  </table>
  
  <div style="margin-top: 1rem; text-align: right;">
    <button id="refreshStatsBtn" class="button" style="padding: 0.5rem 1rem; font-size: 0.9rem;">
      Refresh Stats
    </button>
  </div>
</div>`

// Add to the script section, right after the dashboard cookie check:
`// Load analytics data
