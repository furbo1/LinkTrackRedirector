/**
 * URL Shortener and Click Tracking API
 * 
 * Firebase cleanup policies:
 * - Container images cleanup: 300 days
 * - Function data retention: 300 days
 * - Click data retention: 300 days
 */

const functions = require('firebase-functions');
const express = require('express');
const path = require('path');
const fs = require('fs');
const bodyParser = require('body-parser');
const cookieParser = require('cookie-parser');
const admin = require('firebase-admin');
const crypto = require('crypto');
const diagnosePage = require('./diagnosePage');
const jwt = require('jsonwebtoken');
const cors = require('cors');
const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args)); // Polyfill fetch

// Initialize Firebase Admin SDK
admin.initializeApp();

// Initialize Realtime Database for click tracking
const clicksRef = {
  child: function(path) { 
    console.log(`⚠️ DATABASE OPERATION BLOCKED: child('${path}') call to Realtime Database blocked`);
    return this; 
  },
  push: function() { 
    console.log('⚠️ DATABASE OPERATION BLOCKED: push() call to Realtime Database blocked');
    return { key: 'mock-' + Date.now() }; 
  },
  set: function(data) { 
    console.log('⚠️ DATABASE OPERATION BLOCKED: set() call to Realtime Database blocked', data);
    return Promise.resolve(); 
  },
  update: function(data) { 
    console.log('⚠️ DATABASE OPERATION BLOCKED: update() call to Realtime Database blocked', data);
    return Promise.resolve(); 
  },
  remove: function() { 
    console.log('⚠️ DATABASE OPERATION BLOCKED: remove() call to Realtime Database blocked');
    return Promise.resolve(); 
  },
  once: function(eventType) { 
    console.log(`⚠️ DATABASE OPERATION BLOCKED: once('${eventType}') call to Realtime Database blocked`);
    return Promise.resolve({ 
      val: function() { return null; },
      exists: function() { return false; }
    }); 
  }
};

console.log('✅ CLICKS DATABASE DISABLED: Realtime Database clicks reference has been completely disabled');

// Create our own simple Express app just for Firebase Functions
const app = express();

// Configure Express middleware
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use(cookieParser());

// Set up CORS with appropriate options
app.use(cors({
  origin: '*',  // Allow all origins
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
}));

// Add CORS headers to all responses as a fallback
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  
  // Handle preflight requests
  if (req.method === 'OPTIONS') {
    return res.status(204).send();
  }
  
  next();
});

// Set default content type for all responses
app.use((req, res, next) => {
  res.contentType('application/json');
  next();
});

// Simple in-memory session store (this would be a database in production)
// IMPORTANT: This is NOT suitable for production use as it resets when the function instance is recycled
// In a real app, use Firestore, Firebase RTDB, or another persistent database for sessions
let sessions = {};
console.log('Initializing session store');

// Initialize Firestore for persistent session storage
const db = admin.firestore();
const sessionsCollection = db.collection('sessions');
console.log('Initialized Firestore for persistent sessions');

// Set data retention period to 300 days (in milliseconds)
const DATA_RETENTION_PERIOD = 300 * 24 * 60 * 60 * 1000; // 300 days in milliseconds
const DATA_RETENTION_DAYS = 300;

// URL shortening utilities
// Create an in-memory store for URL mappings
let urlMappings = {};

// Create a Firestore collection for URL mappings
const urlMappingsCollection = db.collection('urlMappings');

// Initialize click tracking collection in Firestore
const clicksCollection = db.collection('clicks');

// Initialize global in-memory click storage
if (!global.inMemoryClicks) global.inMemoryClicks = [];
console.log('Initialized in-memory click storage');

// Load existing URL mappings from Firestore
async function loadUrlMappingsFromFirestore() {
  try {
    console.log('Loading URL mappings from Firestore...');
    const snapshot = await urlMappingsCollection.get();
    
    if (snapshot.empty) {
      console.log('No URL mappings found in Firestore, initializing with defaults');
      return {};
    }
    
    const mappings = {};
    snapshot.forEach(doc => {
      const data = doc.data();
      mappings[doc.id] = data.url;
    });
    
    console.log(`Loaded ${Object.keys(mappings).length} URL mappings from Firestore`);
    return mappings;
  } catch (error) {
    console.error('Error loading URL mappings from Firestore:', error);
    return {};
  }
}

// Call this function at server startup
loadUrlMappingsFromFirestore();

// Define the site domain
const SITE_DOMAIN = 'dls.sale';

// Function to create a short code for a URL
async function createShortCode(url) {
  // First check if we already have a code for this URL
  for (const [code, storedUrl] of Object.entries(urlMappings)) {
    if (storedUrl === url) {
      return code;
    }
  }
  
  // If not, create a new short code
  // Use the first 6 characters of the MD5 hash for uniqueness
  const hash = crypto.createHash('md5').update(url).digest('hex');
  const shortCode = hash.substring(0, 6);
  
  // Store the mapping
  urlMappings[shortCode] = url;
  
  const now = new Date();
  const expiresAt = new Date(now.getTime() + DATA_RETENTION_PERIOD);
  
  // Store the mapping in both memory and Firestore
  urlMappings[shortCode] = url;
  
  try {
    // Also store in Firestore with expiration date
    await urlMappingsCollection.doc(shortCode).set({
      url: url,
      createdAt: now,
      expiresAt: expiresAt
    });
    console.log(`Stored URL mapping in Firestore: ${shortCode} -> ${url}`);
  } catch (error) {
    console.error('Error storing URL mapping in Firestore:', error);
  }
  
  console.log(`Created new short code ${shortCode} for ${url}`);
  
  // Create the short URL with the new domain
  const shortUrl = `https://${SITE_DOMAIN}/r/${shortCode}`;
  
  return shortCode;
}

// Function to retrieve a URL from a short code
async function getUrlFromShortCode(code) {
  // First check in-memory cache
  if (urlMappings[code]) {
    return urlMappings[code];
  }
  
  // If not found, check Firestore
  try {
    const doc = await urlMappingsCollection.doc(code).get();
    if (doc.exists) {
      const mapping = doc.data();
      // Add to in-memory cache
      urlMappings[code] = mapping.url;
      return mapping.url;
    }
  } catch (error) {
    console.error('Error fetching URL mapping from Firestore:', error);
  }
  
  return null;
}

// Find the Realtime Database initialization and disable it
// Typical initialization might look like:
// const database = admin.database();

// Disable all Realtime Database operations
function disableRealtimeDatabase() {
  console.log('⚠️ COST SAVING: All Realtime Database operations disabled to prevent charges');
  
  // Create a mock database object that does nothing
  const mockDb = {
    ref: (path) => {
      console.log(`⚠️ COST SAVING: Realtime Database ref('${path}') operation blocked`);
      return {
        once: (eventType) => {
          console.log(`⚠️ COST SAVING: Realtime Database once('${eventType}') operation blocked`);
          return Promise.resolve({ val: () => ({}), exists: () => false });
        },
        set: (data) => {
          console.log('⚠️ COST SAVING: Realtime Database set operation blocked');
          return Promise.resolve({});
        },
        update: (data) => {
          console.log('⚠️ COST SAVING: Realtime Database update operation blocked');
          return Promise.resolve({});
        },
        push: (data) => {
          console.log('⚠️ COST SAVING: Realtime Database push operation blocked');
          return Promise.resolve({ key: 'mock-key-' + Date.now() });
        },
        child: (childPath) => {
          console.log(`⚠️ COST SAVING: Realtime Database child('${childPath}') operation blocked`);
          return mockDb.ref();
        },
        on: () => {
          console.log('⚠️ COST SAVING: Realtime Database on event listener blocked');
        },
        off: () => {
          console.log('⚠️ COST SAVING: Realtime Database off event listener blocked');
        },
        remove: () => {
          console.log('⚠️ COST SAVING: Realtime Database remove operation blocked');
          return Promise.resolve({});
        },
        orderByChild: (child) => {
          console.log(`⚠️ COST SAVING: Realtime Database orderByChild('${child}') operation blocked`);
          return mockDb.ref();
        }
      };
    }
  };
  
  // If admin.database exists, override it
  if (admin.database) {
    const originalDatabase = admin.database;
    admin.database = () => {
      console.log('⚠️ COST SAVING: Returning mock database to prevent Realtime Database charges');
      return mockDb;
    };
    console.log('⚠️ COST SAVING: Successfully overrode admin.database() function');
  }
  
  // Override any global clicksRef
  if (global.clicksRef) {
    console.log('⚠️ COST SAVING: Replacing global clicksRef with mock implementation');
    global.clicksRef = mockDb.ref('clicks');
  }
  
  // Explicitly initialize the global clicksRef if it doesn't exist
  global.clicksRef = mockDb.ref('clicks');
  
  console.log('⚠️ COST SAVING: Realtime Database completely disabled');
  
  // Return the mock for anyone using this function directly
  return mockDb;
}

// Call this immediately to disable Realtime Database
const mockedDb = disableRealtimeDatabase();
console.log('⚠️ COST SAVING: Realtime Database mocking is active');

// Replace any trackClick function or similar that might use Realtime Database
// Let's look for a trackClick function and override it
async function trackClick(shortCode, decodedUrl, userAgent, referrer, ip, cfCountry) {
  console.log('COST SAVING: Click tracking using Realtime Database disabled');
  
  // Continue with Firestore operations if needed but skip Realtime Database
  try {
    // Add to Firestore if that's still needed
    if (db) {
      const clickData = {
        shortCode: shortCode,
        targetUrl: decodedUrl,
        timestamp: admin.firestore.FieldValue.serverTimestamp(),
        userAgent: userAgent || null,
        referrer: referrer || null,
        ip: ip || null,
        country: cfCountry || null
      };
      
      // Only add to Firestore, not to Realtime Database
      await db.collection('clicks').add(clickData);
      console.log('COST SAVING: Click tracked in Firestore only (Realtime Database disabled)');
    }
  } catch (error) {
    console.error('Error tracking click (Realtime Database disabled):', error);
  }
  
  return true; // Pretend success
}

// Helper functions for session management
async function createSession(email, uid) {
  const sessionToken = Math.random().toString(36).substring(2, 15);
  const sessionData = {
    email,
    uid,
    loggedIn: true,
    createdAt: new Date().toISOString()
  };
  
  // Store in Firestore
  await sessionsCollection.doc(sessionToken).set(sessionData);
  console.log('Created persistent session:', sessionToken);
  
  // Also keep in memory for faster access
  sessions[sessionToken] = sessionData;
  
  return sessionToken;
}

async function getSession(sessionToken) {
  if (!sessionToken) return null;
  
  // First try memory cache
  if (sessions[sessionToken]) {
    return sessions[sessionToken];
  }
  
  // If not in memory, try Firestore
  try {
    const sessionDoc = await sessionsCollection.doc(sessionToken).get();
    if (sessionDoc.exists) {
      const sessionData = sessionDoc.data();
      // Cache in memory
      sessions[sessionToken] = sessionData;
      return sessionData;
    }
  } catch (error) {
    console.error('Error fetching session:', error);
  }
  
  return null;
}

async function deleteSession(sessionToken) {
  if (!sessionToken) return;
  
  // Delete from Firestore
  try {
    await sessionsCollection.doc(sessionToken).delete();
    // Also remove from memory cache
    delete sessions[sessionToken];
  } catch (error) {
    console.error('Error deleting session:', error);
  }
}

// Add an API endpoint for URL shortening
app.post('/api/shorten', async (req, res) => {
  try {
    const url = req.body.url;
    
    // Validate URL
    if (!url) {
      return res.status(400).json({ error: 'URL is required' });
    }
    
    try {
      // Make sure it's a valid URL
      new URL(url);
    } catch (e) {
      return res.status(400).json({ error: 'Invalid URL format' });
    }
    
    // Create a short code
    const shortCode = await createShortCode(url);
    
    // Create the full short URL - use the custom domain
    const shortUrl = `https://${SITE_DOMAIN}/r/${shortCode}`;
    
    // Return the short URL
    res.json({
      originalUrl: url,
      shortCode,
      shortUrl
    });
  } catch (error) {
    console.error('Error shortening URL:', error);
    res.status(500).json({ error: 'Error shortening URL' });
  }
});

// API endpoint to get click statistics
app.get('/api/click-stats', async (req, res) => {
  try {
    console.log('API Request: Getting click statistics');
    console.log('⚠️ COST SAVING: Using Firestore only for stats (RTDB disabled)');
    
    // Explicitly set CORS headers
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Access-Control-Allow-Methods', 'GET, OPTIONS');
    res.set('Access-Control-Allow-Headers', 'Content-Type');
    res.set('Content-Type', 'application/json');
    
    // Get query parameters for filtering
    const shortCodeFilter = req.query.shortCode;
    const dateFilter = req.query.date;
    const countryFilter = req.query.country;
    const sortBy = req.query.sortBy || 'clicks'; // Default sort by clicks
    const sortOrder = req.query.sortOrder || 'desc'; // Default descending
    
    console.log(`Filters applied: shortCode=${shortCodeFilter || 'none'}, date=${dateFilter || 'none'}, country=${countryFilter || 'none'}, sortBy=${sortBy}, sortOrder=${sortOrder}`);
    
    // Initialize stats array
    let stats = [];
    let firestoreAvailable = false;
    let firestoreError = null;
    
    // Skip RTDB and use only Firestore
    console.log('⚠️ COST SAVING: Skipping RTDB operations for click stats');
    const rtdbAvailable = false;
    const rtdbError = 'RTDB is disabled to prevent charges';
    
    // FIRST: Load all URL mappings to ensure we have them available
    console.log('First loading all URL mappings from Firestore');
    try {
      const urlMappingsSnapshot = await urlMappingsCollection.limit(1000).get();
      if (!urlMappingsSnapshot.empty) {
        console.log(`Found ${urlMappingsSnapshot.size} URL mappings in Firestore`);
        
        // Update our in-memory mappings with all mappings from Firestore
        urlMappingsSnapshot.forEach(doc => {
          const shortCode = doc.id;
          const mapping = doc.data();
          if (shortCode && mapping.url) {
            // Add to our global mappings object
            urlMappings[shortCode] = mapping.url;
          }
        });
        
        console.log(`Updated global URL mappings with ${Object.keys(urlMappings).length} entries`);
      } else {
        console.log('No URL mappings found in Firestore');
      }
    } catch (mappingsError) {
      console.error('Error loading URL mappings:', mappingsError);
    }
    
    // SECOND: Check if Firestore is available for click data
    try {
      console.log('Checking if Firestore is available...');
      
      // Quick test to see if Firestore is accessible
      try {
        // Try a simpler operation first - just check if we can access the database
        await db.collection('_test_').doc('_connection_test_').get();
        firestoreAvailable = true;
        
        // Now try a write operation
        try {
          await db.collection('_test_').doc('_connection_test_').set({ 
            timestamp: admin.firestore.FieldValue.serverTimestamp(),
            test: true
          });
          console.log('✅ Firestore write test passed');
        } catch (writeError) {
          console.log('⚠️ Firestore read-only mode: can read but not write');
          // We can still read data even if we can't write
        }
      } catch (testError) {
        console.error('Firestore connection test failed:', testError.message);
        firestoreError = testError.message;
        
        if (testError.message.includes('NOT_FOUND') || testError.message.includes('does not exist')) {
          console.error('Firestore database does not exist yet. Cannot retrieve stats from Firestore.');
        } else if (testError.message.includes('PERMISSION_DENIED')) {
          console.error('Permission denied accessing Firestore. Check service account permissions.');
        }
      }
    } catch (firestoreError) {
      console.error('Error checking Firestore:', firestoreError);
      return res.status(500).json({
        error: 'Failed to retrieve click statistics',
        message: firestoreError.message
      });
    }
    
    // If no results and both data sources failed
    if (stats.length === 0) {
        error: 'Error during deletion process',
        message: deleteError.message
      });
    }
    
  } catch (error) {
    console.error('Error in delete URL endpoint:', error);
    return res.status(500).json({
      error: 'Failed to delete URL mapping',
      message: error.message
    });
  }
});

// Add a GET endpoint to fetch URL info for a short code (for testing)
app.get('/api/get-url/:shortCode', async (req, res) => {
  try {
    const shortCode = req.params.shortCode;
    
    if (!shortCode) {
      return res.status(400).json({
        error: 'Short code is required'
      });
    }
    
    console.log(`Looking up URL info for shortCode: ${shortCode}`);
    
    // Check in-memory cache first
    let targetUrl = urlMappings[shortCode];
    let source = 'memory cache';
    
    // If not found in memory, check Firestore
    if (!targetUrl) {
      try {
        const doc = await urlMappingsCollection.doc(shortCode).get();
        if (doc.exists) {
          targetUrl = doc.data().url;
          source = 'Firestore';
        }
      } catch (err) {
        console.error(`Error checking Firestore for shortCode ${shortCode}:`, err);
      }
    }
    
    // If URL not found in either location
    if (!targetUrl) {
      return res.status(404).json({
        error: 'URL mapping not found'
      });
    }
    
    // Return the URL info
    return res.status(200).json({
      shortCode: shortCode,
      url: targetUrl,
      shortUrl: `https://${SITE_DOMAIN}/r/${shortCode}`,
      source: source
    });
    
  } catch (error) {
    console.error('Error in get URL endpoint:', error);
    return res.status(500).json({
      error: 'Failed to get URL information',
      message: error.message
    });
  }
});

// Special route specifically for direct URL deletion that bypasses Firebase hosting routing
app.delete('/delete-url-direct/:shortCode', async (req, res) => {
  try {
    const shortCode = req.params.shortCode;
    
    // Log all request details for debugging
    console.log('\n--------- DIRECT DELETE REQUEST ---------');
    console.log(`Direct delete request for shortCode: ${shortCode}`);
    console.log('- Headers:', JSON.stringify(req.headers, null, 2));
    console.log('- Origin:', req.get('origin'));
    console.log('- Referrer:', req.get('referrer'));
    console.log('- Method:', req.method);
    console.log('- IP:', req.ip);
    console.log('---------------------------------\n');
    
    // Enable CORS for all origins
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Access-Control-Allow-Methods', 'DELETE, OPTIONS');
    res.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Delete-Token');
    res.set('Content-Type', 'application/json');
    
    // Handle preflight requests
    if (req.method === 'OPTIONS') {
      console.log('Responding to OPTIONS preflight request');
      return res.status(204).send();
    }
    
    if (!shortCode) {
      console.log('Error: No shortCode provided in request');
      return res.status(400).json({
        error: 'Short code is required'
      });
    }
    
    console.log(`Attempting to delete URL mapping for shortCode: ${shortCode}`);
    
    // First check if the URL mapping exists
    let existingUrl = urlMappings[shortCode];
    console.log(`URL in memory cache: ${existingUrl ? 'found' : 'not found'}`);
    
    if (!existingUrl) {
      try {
        // Check in Firestore
        const doc = await urlMappingsCollection.doc(shortCode).get();
        if (doc.exists) {
          existingUrl = doc.data().url;
          console.log(`URL found in Firestore: ${existingUrl}`);
        } else {
          console.log(`URL not found in Firestore`);
        }
      } catch (err) {
        console.error(`Error checking Firestore for shortCode ${shortCode}:`, err);
      }
    }
    
    if (!existingUrl) {
      console.log(`URL mapping not found for ${shortCode}, sending 404 response`);
      return res.status(404).json({
        error: 'URL mapping not found'
      });
    }
    
    // Wrap all deletion operations in a try/catch to ensure robust handling
    try {
      // Delete from in-memory cache
      if (urlMappings[shortCode]) {
        delete urlMappings[shortCode];
        console.log(`Deleted shortCode ${shortCode} from in-memory cache`);
      }
      
      // Track successful operations
      const operations = [];
      
      // Delete from Firestore
      try {
        await urlMappingsCollection.doc(shortCode).delete();
        console.log(`Deleted shortCode ${shortCode} from Firestore`);
        operations.push('url mapping from Firestore');
      } catch (err) {
        console.error(`Error deleting from Firestore for shortCode ${shortCode}:`, err);
        // Continue even if Firestore delete fails
      }
      
      // Delete related click data from Firestore
      try {
        // Find all click documents for this shortCode
        const clickQuery = await clicksCollection.where('shortCode', '==', shortCode).get();
        
        if (!clickQuery.empty) {
          const batch = db.batch();
          clickQuery.forEach(doc => {
            batch.delete(doc.ref);
          });
          
          await batch.commit();
          console.log(`Deleted ${clickQuery.size} click records for shortCode ${shortCode} from Firestore`);
          operations.push(`${clickQuery.size} click records from Firestore`);
        }
      } catch (err) {
        console.error(`Error deleting click data from Firestore for shortCode ${shortCode}:`, err);
        // Continue even if click data delete fails
      }
      
      // Delete summary document if it exists
      try {
        const summaryDoc = await clicksCollection.doc(`summary_${shortCode}`).get();
        if (summaryDoc.exists) {
          await clicksCollection.doc(`summary_${shortCode}`).delete();
          console.log(`Deleted summary document for shortCode ${shortCode}`);
          operations.push('summary document');
        }
      } catch (err) {
        console.error(`Error deleting summary document for shortCode ${shortCode}:`, err);
        // Continue even if summary delete fails
      }
      
      // Delete from Realtime Database
      try {
        await clicksRef.child(shortCode).remove();
        console.log(`Deleted click data for shortCode ${shortCode} from RTDB`);
        operations.push('click data from Realtime Database');
      } catch (err) {
        console.error(`Error deleting from RTDB for shortCode ${shortCode}:`, err);
        // Continue even if RTDB delete fails
      }
      
      // Return success response
      const operationSummary = operations.length > 0 
          ? `Deleted: ${operations.join(', ')}` 
          : 'Deletion partially successful';
      
      console.log(`Successfully deleted URL mapping for ${shortCode}, sending success response`);
      console.log('Operations summary:', operationSummary);
      
      // Send the successful response
      return res.status(200).json({
        success: true,
        message: `URL mapping and associated data for "${shortCode}" has been deleted successfully`,
        operations: operationSummary,
        shortCode: shortCode
      });
      
    } catch (deleteError) {
      console.error('Error during deletion process:', deleteError);
      return res.status(500).json({
        error: 'Error during deletion process',
        message: deleteError.message,
        shortCode: shortCode
      });
    }
  } catch (error) {
    console.error('Delete endpoint error:', error);
    return res.status(500).json({
      error: 'Server error',
      message: error.message
    });
  }
});

// Add a POST endpoint for URL actions (including delete) to bypass Firebase hosting routing issues
app.post('/api/url-action', async (req, res) => {
  try {
    console.log('\n--------- URL ACTION REQUEST ---------');
    console.log('Request body:', JSON.stringify(req.body, null, 2));
    console.log('Headers:', JSON.stringify(req.headers, null, 2));
    console.log('---------------------------------\n');
    
    // Set CORS headers
    res.set('Access-Control-Allow-Origin', '*');
    res.set('Access-Control-Allow-Methods', 'POST, OPTIONS');
    res.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Delete-Token');
    res.set('Content-Type', 'application/json');
    
    // Handle preflight
    if (req.method === 'OPTIONS') {
      return res.status(204).send();
    }
    
    // Check if we have a valid request body
    if (!req.body) {
      return res.status(400).json({
        error: 'Missing request body'
      });
    }
    
    const { action, shortCode } = req.body;
    
    if (!action) {
      return res.status(400).json({
        error: 'Missing action parameter'
      });
    }
    
    if (!shortCode) {
      return res.status(400).json({
        error: 'Missing shortCode parameter'
      });
    }
    
    console.log(`Processing action '${action}' for shortCode: ${shortCode}`);
    
    // Handle different actions
    switch (action.toLowerCase()) {
      case 'delete':
        return await handleDeleteAction(shortCode, req, res);
      
      case 'info':
        return await handleInfoAction(shortCode, req, res);
        
      default:
        return res.status(400).json({
          error: `Unknown action: ${action}`
        });
    }
  } catch (error) {
    console.error('Error in URL action endpoint:', error);
    return res.status(500).json({
      error: 'Server error',
      message: error.message
    });
  }
});

// Handler for URL delete action
async function handleDeleteAction(shortCode, req, res) {
  console.log('Handling DELETE action for shortCode:', shortCode);
  
  // Validate shortCode
  if (!shortCode) {
    console.error('No short code provided for deletion');
    return res.status(400).json({ error: "No short code provided for deletion" });
  }
  
  console.log('Checking if URL mapping exists in cache');
  // Check if the URL exists in memory cache first
  let exists = urlMappings[shortCode] ? true : false;
  let urlExisted = exists;
  
  if (exists) {
    console.log('URL mapping found in cache, deleting from cache');
    // Delete from memory cache
    delete urlMappings[shortCode];
  }
  
  try {
    console.log('Checking if URL mapping exists in Firestore');
    // Check if exists in Firestore
    const urlDocRef = db.collection('urls').doc(shortCode);
    const urlDoc = await urlDocRef.get();
    
    if (urlDoc.exists) {
      console.log('URL mapping found in Firestore, deleting...');
      urlExisted = true;
      
      // Delete the URL mapping from Firestore
      await urlDocRef.delete();
      console.log('URL mapping deleted from Firestore');
      
      // Delete related click data
      try {
        console.log('Deleting click summary data...');
        const summaryDocRef = db.collection('click-summaries').doc(shortCode);
        await summaryDocRef.delete();
        console.log('Click summary deleted');
      } catch (summaryErr) {
        console.error('Error deleting click summary:', summaryErr);
        // Continue with other deletions even if this fails
      }
      
      try {
        console.log('Deleting detailed click data...');
        // Delete click data collection
        const clicksRef = db.collection('clicks').where('shortCode', '==', shortCode);
        const clickDocs = await clicksRef.get();
        
        // Batch delete all click documents
        const batch = db.batch();
        let batchCount = 0;
        
        clickDocs.forEach(doc => {
          batch.delete(doc.ref);
          batchCount++;
        });
        
        if (batchCount > 0) {
          await batch.commit();
          console.log(`Deleted ${batchCount} click records from Firestore`);
        } else {
          console.log('No click records found to delete');
        }
      } catch (clickErr) {
        console.error('Error deleting click data:', clickErr);
        // Continue even if this fails
      }
      
      try {
        console.log('Deleting real-time click data...');
        // Delete from realtime database
        // DISABLED TO PREVENT CHARGES
        // const rtdbRef = admin.database().ref(`clicks/${shortCode}`);
        // await rtdbRef.remove();
        console.log('⚠️ COST SAVING: RTDB delete operation blocked for shortCode:', shortCode);
        console.log('Real-time click data deletion skipped to prevent RTDB charges');
      } catch (rtdbErr) {
        console.error('Error deleting from realtime DB:', rtdbErr);
        // Continue even if this fails
      }
    } else {
      console.log('URL mapping not found in Firestore');
      if (!urlExisted) {
        console.error('URL mapping not found in cache or Firestore');
        return res.status(404).json({ error: `URL mapping with short code '${shortCode}' not found` });
      }
    }
    
    // Set Content-Type header explicitly
    res.set('Content-Type', 'application/json');
    
    // Return success response with simple JSON
    const responseData = { 
      success: true, 
      message: `URL mapping with short code '${shortCode}' has been deleted successfully`
    };
    
    console.log('Delete operation completed successfully, sending response:', responseData);
    return res.status(200).json(responseData);
  } catch (error) {
    console.error('Error in delete operation:', error);
    
    // Set Content-Type header explicitly
    res.set('Content-Type', 'application/json');
    
    return res.status(500).json({ error: `Error deleting URL mapping: ${error.message}` });
  }
}

// Handler for URL info action
async function handleInfoAction(shortCode, req, res) {
  try {
    console.log(`Looking up URL info for shortCode: ${shortCode}`);
    
    // Check in-memory cache first
    let targetUrl = urlMappings[shortCode];
    let source = 'memory cache';
    
    // If not found in memory, check Firestore
    if (!targetUrl) {
      try {
        const doc = await urlMappingsCollection.doc(shortCode).get();
        if (doc.exists) {
          targetUrl = doc.data().url;
          source = 'Firestore';
        }
      } catch (err) {
        console.error(`Error checking Firestore for shortCode ${shortCode}:`, err);
      }
    }
    
    // If URL not found in either location
    if (!targetUrl) {
      return res.status(404).json({
        error: 'URL mapping not found',
        shortCode: shortCode,
        action: 'info'
      });
    }
    
    // Return the URL info
    return res.status(200).json({
      shortCode: shortCode,
      url: targetUrl,
      shortUrl: `https://${SITE_DOMAIN}/r/${shortCode}`,
      source: source,
      action: 'info'
    });
    
  } catch (error) {
    console.error('Error in info action:', error);
    return res.status(500).json({
      error: 'Failed to get URL information',
      message: error.message,
      action: 'info'
    });
  }
}

// Add a direct delete endpoint for debugging and testing
// This bypasses regular middleware and allows direct access
app.get('/direct-delete/:shortCode', async (req, res) => {
  const shortCode = req.params.shortCode;
  console.log('==== DIRECT DELETE TEST ENDPOINT CALLED ====');
  console.log('Received delete request for shortCode:', shortCode);
  console.log('Headers:', JSON.stringify(req.headers, null, 2));
  
  // Set CORS headers to handle browser requests
  res.set('Access-Control-Allow-Origin', '*');
  res.set('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, DELETE');
  res.set('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Delete-Token');
  res.set('Content-Type', 'application/json');

  try {
    // Basic validation
    if (!shortCode) {
      console.log('No shortCode provided');
      return res.status(400).json({ error: 'No shortCode provided' });
    }
    
    // Check if exists in memory
    console.log('Checking if URL mapping exists in memory cache');
    let exists = urlMappings[shortCode] ? true : false;
    let urlExisted = exists;
    
    if (exists) {
      console.log('URL mapping found in memory, deleting');
      delete urlMappings[shortCode];
    }
    
    try {
      // Check if exists in Firestore
      console.log('Checking if URL mapping exists in Firestore');
      const urlDocRef = db.collection('urls').doc(shortCode);
      const urlDoc = await urlDocRef.get();
      
      if (urlDoc.exists) {
        console.log('URL mapping found in Firestore, deleting');
        urlExisted = true;
        
        // Delete the URL mapping from Firestore
        await urlDocRef.delete();
        console.log('URL mapping deleted from Firestore');
        
        // Delete click data and summaries
        try {
          console.log('Attempting to delete related click data');
          const summaryDocRef = db.collection('click-summaries').doc(shortCode);
          await summaryDocRef.delete();
          console.log('Click summary deleted');
        } catch (err) {
          console.error('Error deleting click summary:', err);
        }
        
        // Delete from realtime database
        try {
          console.log('Attempting to delete from realtime database');
          // DISABLED TO PREVENT CHARGES
          // const rtdbRef = admin.database().ref(`clicks/${shortCode}`);
          // await rtdbRef.remove();
          console.log('⚠️ COST SAVING: RTDB delete operation blocked for shortCode:', shortCode);
          console.log('Realtime database deletion skipped to prevent RTDB charges');
        } catch (err) {
          console.error('Error deleting from realtime DB:', err);
        }
      } else {
        console.log('URL mapping not found in Firestore');
        if (!urlExisted) {
          console.log('URL mapping not found in memory or Firestore');
          return res.status(404).json({ error: `URL mapping with short code '${shortCode}' not found` });
        }
      }
      
      console.log('Delete operation successful');
      
      // Create a simple response object
      const responseData = { 
        success: true, 
        message: `URL mapping with short code '${shortCode}' has been deleted successfully`
      };
      
      console.log('Sending success response:', responseData);
      return res.status(200).json(responseData);
    } catch (error) {
      console.error('Error in Firestore operations:', error);
      return res.status(500).json({ error: `Error in Firestore operations: ${error.message}` });
    }
  } catch (error) {
    console.error('Unhandled error in direct delete endpoint:', error);
    return res.status(500).json({ error: `Unhandled error: ${error.message}` });
  }
});

// Restore the original /api/url-info endpoint to its functional state before March 30th
app.get('/api/url-info', async (req, res) => {
  const url = req.query.url;
  
  // Validate URL
  if (!url) {
    return res.status(400).json({ error: 'URL parameter is required' });
  }
  
  // Add CORS headers
  res.set('Access-Control-Allow-Origin', '*');
  res.set('Access-Control-Allow-Methods', 'GET, OPTIONS');
  res.set('Access-Control-Allow-Headers', 'Content-Type');
  
  try {
    // Special case handling for Temu links which often cause issues
    if (url.includes('temu.com') || url.includes('temu.to')) {
      console.log('Temu URL detected, using predefined metadata');
      return res.json({
        title: 'Temu: Shop Like A Billionaire',
        description: 'Shop quality merchandise at incredibly low prices. Discover a wide selection of products with fast delivery.',
        image: 'https://img.kwcdn.com/product/Fancyalgo/VirtualModelMatting/c50edcbeef1a03f17a8e35065d04e99b.jpg',
        domain: url.includes('temu.com') ? 'temu.com' : 'temu.to'
      });
    }
    
    // Using fetch to get the URL content
    console.log('Fetching URL info for: ' + url);
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      },
      timeout: 5000
    });
    
    const html = await response.text();
    
    // Extract metadata from HTML
    const metadata = {
      title: extractMetaTag(html, 'title') || extractTitle(html) || 'No title found',
      description: extractMetaTag(html, 'description') || 'No description available',
      image: extractMetaTag(html, 'image') || extractFirstImage(html) || null,
      domain: new URL(url).hostname
    };
    
    return res.json(metadata);
  } catch (error) {
    console.error('Error fetching URL info:', error);
    
    // Try to parse domain for a basic response
    let domain = 'unknown';
    try {
      domain = new URL(url).hostname;
    } catch (e) {
      // Ignore parsing errors
    }
    
    return res.json({
      title: domain || 'Could not fetch URL info',
      description: 'Could not fetch metadata for this URL.',
      image: null,
      domain: domain,
      error: error.message
    });
  }
});

// Helper functions for URL info
function extractMetaTag(html, property) {
  // Try Open Graph tags first
  const ogMatch = html.match(new RegExp(`<meta\\s+property=["']og:${property}["']\\s+content=["']([^"']+)["']`, 'i'));
  if (ogMatch) return ogMatch[1];
  
  // Try Twitter tags
  const twitterMatch = html.match(new RegExp(`<meta\\s+name=["']twitter:${property}["']\\s+content=["']([^"']+)["']`, 'i'));
  if (twitterMatch) return twitterMatch[1];
  
  // Try regular meta tags
  const metaMatch = html.match(new RegExp(`<meta\\s+name=["']${property}["']\\s+content=["']([^"']+)["']`, 'i'));
  if (metaMatch) return metaMatch[1];
  
  return null;
}

function extractTitle(html) {
  const match = html.match(/<title>([^<]+)<\/title>/i);
  return match ? match[1].trim() : null;
}

function extractFirstImage(html) {
  const match = html.match(/<img[^>]+src=["']([^"']+)["'][^>]*>/i);
  return match ? match[1] : null;
}

// DISABLE REALTIME DATABASE COMPLETELY - Cost reduction measure
// Add this early in the file, right after the admin initialization
let originalDatabase = null;
if (admin.database) {
  originalDatabase = admin.database;
  admin.database = function() {
    console.log('⚠️ DATABASE ACCESS BLOCKED: Realtime Database has been disabled to reduce costs');
    return {
      ref: function() {
        console.log('⚠️ DATABASE OPERATION BLOCKED: ref() call to Realtime Database blocked');
        return {
          child: function() { return this; },
          push: function() { return { key: 'mock-' + Date.now() }; },
          set: function() { return Promise.resolve(); },
          update: function() { return Promise.resolve(); },
          remove: function() { return Promise.resolve(); },
          once: function() { return Promise.resolve({ val: function() { return null; } }); }
        };
      }
    };
  };
  console.log('✅ DATABASE DISABLED: Realtime Database access has been blocked to prevent charges');
}

// Instead of redefining clicksRef here, we'll add a comment to look for it later
console.log('✅ CLICKS DATABASE NEEDS DISABLING: Looking for clicksRef declaration to modify');